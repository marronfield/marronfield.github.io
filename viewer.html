<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>接合測定（閲覧のみ）</title>
    <link rel="icon" href="data:image/svg+xml;charset=utf8,%3Csvg%20width%3D%22100%22%20height%3D%22100%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20fill%3D%22%23660099%22%20stroke%3D%22none%22%20d%3D%22M%200%2010%20Q%200%200%2010%200%20h%2080%20Q%20100%200%20100%2010%20v%2080%20Q%20100%20100%2090%20100%20h%20-80%20Q%200%20100%200%2090%20z%22%3E%3C%2Fpath%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22%23ffffff%22%20stroke-width%3D%228%22%20stroke-linecap%3D%22round%22%20stroke-linejoin%3D%22round%22%20d%3D%22M%2090%2010%20l%20-10%2010%20v%2030%20h%20-60%20v%2030%20l%20-10%2010%20M%2080%2030%20h%20-30%20v%2040%20h%20-30%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E" type="image/svg+xml">
    <style>
        @keyframes blink {
            to {
                opacity: 0;
            }
        }

		@keyframes rotate {
			to {
				transform: rotate(360deg);
			}
		}

        :root {
            user-select: none;

            --text: #333;
            --text-secondary: #444;
            --text-link: #1a0dab;
            --background: #fff;
            --border: #ccc;
            --border-active: #2673cb;
            --shadow: rgba(63, 63, 63, 0.2);
            --shadow-active: rgba(51, 170, 255, 0.5);

            @media (prefers-color-scheme: dark) {
                --text: #ccc;
                --text-secondary: #bbb;
                --text-link: #99c3ff;
                --background: #111;
                --border: #444;
                --shadow: rgba(192, 192, 192, 0.2);
                --shadow-active: rgba(0, 104, 223, 0.5);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;

            background-color: var(--background);
            color: var(--text);
            font-family: system-ui;
            display: flex;
        }

        a, a:visited {
            color: var(--text-link);
        }

        button {
            background-color: transparent;
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 0.95em;
            font-weight: bold;
            font-family: inherit;
            padding: 3px 6px;
        }

        button.large {
            font-size: 1.1em;
            padding: 4px 8px;
        }

        button.icon {
            margin: 0;
            padding: 4px;
            font-size: 0;
        }

        select, input[type="number"], input[type="text"], input[type="checkbox"] {
            margin: 0.25em;
            user-select: none;

            background-color: transparent;
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            padding: 0.25em;
        }

        select:first-child, input[type="number"]:first-child, input[type="text"]:first-child, input[type="checkbox"]:first-child {
            margin-left: 0;
        }

        select:last-child, input[type="number"]:last-child, input[type="text"]:last-child {
            margin-right: 0;
        }

        select:focus {
            background-color: var(--background);
        }

        input[type="number"], input[type="text"] {
            padding: 0.25em 0.5em;
        }

        label {
            cursor: pointer;
            user-select: none;
        }

        [hidden] {
            display: none !important;
        }

        [inert] {
            opacity: 0.4;
            pointer-events: none;
        }

        [tabindex]:not([tabindex^="-"]):focus {
            outline: var(--border) solid 1px;
            outline-offset: -1px;
        }

        *:invalid {
            background-image: linear-gradient(#f003, #f003);
        }

        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background-color: var(--border);
            border-radius: 4px;
        }

        button, .clickable {
            cursor: pointer;
            user-select: none;
        }

        button:hover, .clickable:hover {
            background-color: var(--shadow);
        }

        button:active, .clickable:active {
            opacity: 0.8;
        }

        .resize-border {
            position: absolute;
            z-index: 2;

            transition: background-color .25s;
            user-select: none;
        }

        .resize-border:hover, .resize-border:active {
            background-color: var(--border);
        }

        .resize-border:active {
            opacity: 0.8;
        }

        .align-center {
            display: flex;
            align-items: center;
        }

        .fullscreen {
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            z-index: 999;
        }

        .hline {
            width: 100%;
            margin: 4px 0;

            background-color: var(--border);
            border-top: 1px solid var(--border);
        }

		.spinner {
			width: 1.2em;
			height: 1.2em;
            margin: 4px;
			border-radius: 50%;
			border: .15em solid var(--border);
			border-top-color: var(--text);
			animation: rotate 1.5s linear infinite;
            display: inline-block;
		}

        #plot {
            position: relative;
            flex-grow: 1;
            min-width: 0;
        }

        #plotcontrols, #plotcontrols2 {
            position: absolute;
            z-index: 1;

            background-color: color-mix(in srgb, var(--background) 75%, transparent);
            backdrop-filter: blur(20px);
            border-radius: 8px;
            opacity: 0;
            padding: 4px 8px;
            transition: opacity .2s ease-in-out;
        }

        #plotcontrols {
            left: 4px;
            top: 4px;
            width: 250px;
            max-height: 75px;

            display: flex;
            flex-direction: column;
            overflow: hidden;

            &.overflow:hover {
                max-height: none;
            }

            &.overflow:not(:hover) {
                border-bottom-left-radius: 0;
                border-bottom-right-radius: 0;
                mask-image: linear-gradient(to bottom, black 50%, transparent);
            }
        }

        #plotcontrols2 {
            right: 4px;
            bottom: 4px;
            
            display: flex;
            align-items: center;
            gap: 4px;
        }

        #plot:has(.nsewdrag:hover:not(:active)) :is(#plotcontrols, #plotcontrols2),
        #plot:not(:has(.nsewdrag)):hover :is(#plotcontrols, #plotcontrols2),
        :is(#plotcontrols, #plotcontrols2):hover {
            opacity: 1;
        }

        #controls {
            width: 250px;
            height: 100%;
            min-width: 200px;
            max-width: 100%;
            z-index: 1;

            background-color: var(--background);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }

        #measurement {
            flex-shrink: 0;
            min-height: 200px;
            max-height: 100%;

            border-bottom: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: hidden;

            > * {
                padding: 0 8px;

                &:first-child {
                    padding-top: 8px;
                }

                &:last-child {
                    padding-bottom: 8px;
                }
            }
        }

        #results {
            flex-grow: 1;
            min-height: 0;
            max-height: 100%;

            display: flex;
            flex-direction: column;
            outline: none;
            overflow-y: hidden;

            > * {
                padding: 0 8px;

                &:first-child {
                    padding-top: 8px;
                }

                &:last-child {
                    padding-bottom: 8px;
                }
            }
        }

        .result {
            width: 100%;

            display: flex;
            gap: 4px;
            align-items: center;
            padding: 0 8px;
            
            > .name {
                min-width: 0;
                flex-grow: 1;

                display: flex;
                font-weight: bold;
                padding: 1px 0 2px;

                > * {
                    white-space: nowrap;
                }

                :first-child {
                    overflow: hidden;
                    text-overflow: ellipsis;
                }
            }

            > .buttons {
                display: flex;
                gap: 4px;

                > * {
                    display: grid;
                    place-items: center;
                }

                > *:active {
                    opacity: 0.8;
                }
            }

            &:not(:hover) .buttons {
                display: none;
            }

            &:has(.buttons:active) {
                opacity: 1 !important;
            }

            &:not(:hover):is(:not(.saved), .running)::after {
                margin: 3px;

                border: 4px solid var(--text);
                border-radius: 4px;
                content: "";
            }

            &.running::after {
                animation: blink 1s ease-in infinite;
            }

            &.selected {
                background-color: var(--border);
                outline-color: var(--border-active) !important;
            }

            &.rename {
                background-color: var(--border) !important;
            }

            &.rename :not(.marker), &.rename::after {
                visibility: hidden;
                width: 0;
            }

            &.group, &.group-item {
                position: relative;
                
                padding-left: 30px;
            }

            &.group .marker {
                position: absolute;
                left: 0;
                width: 30px;
                height: 100%;

                background-color: var(--text);
                content: "";
                mask: url("data:image/svg+xml;charset=utf8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2010%2010%22%20fill%3D%22none%22%20stroke%3D%22currentColor%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M%203%201%20l%204%204%20l%20-4%204%22%2F%3E%3C%2Fsvg%3E");
                mask-position: center;
                mask-repeat: no-repeat;
            }
            
            &.group.expanded .marker {
                transform: rotate(90deg);
            }
        }

        #results:focus-within .result.selected {
            background-color: var(--shadow-active);
        }

        .logger {
            position: fixed;
            left: 0;
            bottom: 0;
            max-height: 200px;
            margin: 10px;
            z-index: 1;

            background-color: color-mix(in srgb, var(--background) 75%, transparent);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow-y: auto;

            transform: translateX(-150%);

            &:empty {
                display: none;
            }
        }

        .namedform {
            width: 100%;

            display: flex;
            align-items: center;
            
            > .name {
                width: 60px;
                white-space: nowrap;
            }

            > .form {
                flex-grow: 1;
                width: 0;
            }

            > .unitform {
                width: 60px;
            }
        }

        .popup {
            position: absolute;
            z-index: 9999;

            background-color: color-mix(in srgb, var(--background) 75%, transparent);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 0 5px var(--shadow);
        }

        .contextmenu {
            display: flex;
            flex-direction: column;
            padding: 4px;

            &:has(> :only-child) {
                padding: 0;

                > :only-child {
                    border-radius: inherit;
                    padding: 4px 8px;
                }
            }

            > .clickable {
                border-radius: 4px;
                display: flex;
                align-items: center;
                padding: 4px 8px;
            }

            > button {
                display: flex;
                border: none;
                align-items: center;
                outline: none;

                > .icon {
                    width: 20px;

                    display: flex;
                    align-items: center;
                }
            }
        }

        .selectmenu {
            > .selected {
                background-color: var(--shadow-active);
            }
        }

        .modal {
            background-color: var(--background);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 0 5px var(--shadow);
        }
    </style>

    <script>
        MathJax = {
            tex2jax: {
                inlineMath: [["$", "$"]],
                preview: "none",
            },
            messageStyle: "none",
            showMathMenu: false,
            menuSettings: {
                inTabOrder: false,
            },
            "fast-preview": {
                disabled: true,
            },
        };
        document.cookie = "mjx.menu=zoom:None";
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js" charset="utf-8"></script>
</head>

<body oncontextmenu="return false">
    <div id="plot" tabindex="0">
        <div id="plotcontrols"></div>
        <div id="plotcontrols2"></div>
    </div>
    <div id="controls">
        <div id="measurement"></div>
        <div id="results" tabindex="0"></div>
    </div>

    <script>
        const isMac = navigator.userAgent.includes("Mac OS X");
        const $ = query => document.querySelector(query);
        const $$ = query => [...document.querySelectorAll(query)];

        const createElement = (name, props, ...children) => {
            props ??= {};

            const element = document.createElement(name);

            for (const [key, value] of Object.entries(props)) {
                if (key === "style") {
                    Object.assign(element.style, value);
                }
                else if (key === "class") {
                    for (const className of value.split(/\s+/)) {
                        element.classList.add(className);
                    }
                }
                else if (key === "attrs") {
                    for (const [key, _value] of Object.entries(value)) {
                        element.setAttribute(key, _value);
                    }
                }
                else if (key === "dataset") {
                    Object.assign(element.dataset, value);
                }
                else {
                    element[key] = value;
                }
            }

            element.append(...children);

            return element;
        };

        const round = (value, { precision = 12, minOrder } = {}) => {
            const { abs, ceil, log10, min, round } = Math;
            if (minOrder) precision = min(ceil(log10(abs(value / minOrder))), precision);
            
            if (precision > 0) return Number(value.toPrecision(precision));
            else if (precision < 0) return 0;
            else {
                const order = 10 ** ceil(log10(abs(value)));
                return Number((round(value / order) * order).toPrecision(1));
            }
        };

        const transpose = a => a.reduce((p, c) => c.length < p.length ? c : p).map((_, c) => a.map(r => r[c]));

        const getSIPrefix = (n, pow = 1) => {
            const { abs, log10, floor, min, max, sign } = Math;
            const a = !n || !pow ? 0 : max(-5, min(floor(log10(abs(n)) / 3 / abs(pow)) * sign(pow), 5));

            return {
                name: ["f", "p", "n", "μ", "m", "", "k", "M", "G", "T", "P"][a + 5],
                value: 1000 ** (a * pow),
            };
        };
        
        const readlines = response => {
            const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
            
            return async function*() {
                let buffer = "";

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        if (buffer) yield buffer;
                        break;
                    }

                    const [firstline, ...restlines] = value.split("\n");
                    buffer += firstline;

                    if (restlines.length) {
                        yield buffer;
                        yield* restlines.slice(0, -1);

                        buffer = restlines.at(-1);
                    }
                }
            }();
        };

        const ResizeBorder = class {
            elem;
            #target;
            #width;
            #side;

            static add(...args) {
                $("body").append(new ResizeBorder(...args).elem);
            }

            constructor(target, side = "left", width = 6) {
                this.#target = typeof target === "string" ? $(target) : target;
                this.#width = width;
                this.#side = side;

                const onmousemove = e => {
                    if (!e.buttons) return;

                    const { left, right, top, bottom, width, height } = this.#target.getBoundingClientRect();

                    if (this.#side === "left" || this.#side === "right") {
                        const value = this.#side === "left" ? width - (e.x - left) : width + (e.x - right);

                        if (value < 100) {
                            this.#target.style.width = "0";
                            this.#target.style.minWidth = "0";
                            this.#target.style.border = "none";
                        }
                        else {
                            this.#target.style.width = `${value}px`;
                            this.#target.style.minWidth = "";
                            this.#target.style.border = "";
                        }
                    }
                    else if (this.#side === "top" || this.#side === "bottom") {
                        const value = this.#side === "top" ? height - (e.y - top) : height + (e.y - bottom);

                        if (value < 100) {
                            this.#target.style.height = "0";
                            this.#target.style.minHeight = "0";
                            this.#target.style.border = "none";
                        }
                        else {
                            this.#target.style.height = `${value}px`;
                            this.#target.style.minHeight = "";
                            this.#target.style.border = "";
                        }
                    }
                };

                this.elem = createElement("div", {
                    class: `resize-border`,
                    style: ["left", "right"].includes(this.#side) ? {
                        width: `${this.#width}px`,
                        height: "100%",
                        cursor: "col-resize",
                    } : {
                        width: "100%",
                        height: `${this.#width}px`,
                        cursor: "row-resize",
                    },
                    draggable: false,

                    ondblclick: () => {
                        if (this.#side === "left" || this.#side === "right") {
                            this.#target.style.width = "";
                            this.#target.style.minWidth = "";
                        }
                        else if (this.#side === "top" || this.#side === "bottom") {
                            this.#target.style.height = "";
                            this.#target.style.minHeight = "";
                        }

                        this.#target.style.border = "";
                    },
                    onpointerdown: e => {
                        this.elem.onmousemove = onmousemove;
                        this.elem.setPointerCapture(e.pointerId);
                    },
                    onmouseup: () => this.elem.onmousemove = null,
                });

                addEventListener("resize", () => this.#update());
                new ResizeObserver(() => this.#update()).observe(this.#target);

                this.#update();
            }

            #update() {
                const { left, right, top, bottom, width, height } = this.#target.getBoundingClientRect();

                if (["left", "right"].includes(this.#side)) {
                    this.elem.style.left = `${{left, right}[this.#side] - this.#width / 2}px`;
                    this.elem.style.top = `${top}px`;
                    this.elem.style.height = `${height}px`;
                }
                else {
                    this.elem.style.left = `${left}px`;
                    this.elem.style.top = `${{top, bottom}[this.#side] - this.#width / 2}px`;
                    this.elem.style.width = `${width}px`;
                }
            }
        };

        const Popup = class {
            elem;
            onclose;
            fixed = false;
            #isopen = false;

            constructor(props, ...children) {
                this.elem = createElement("div", props, ...children);
                this.elem.classList.add("popup");
                this.elem.hidden = true;
                this.elem.tabIndex = "0";

                $("body").append(this.elem);

                this.elem.addEventListener("focusout", e => {
                    if (this.#isopen && !this.fixed && !this.elem.contains(e.relatedTarget)) this.close();
                });
                addEventListener("mousedown", e => {
                    if (this.#isopen && !this.fixed && !this.elem.contains(e.target)) this.close();
                });
                addEventListener("fullscreenchange", () => {
                    if (document.fullscreenElement) document.fullscreenElement.append(this.elem);
                    else $("body").append(this.elem);
                });
            }

            open({ x = 0, y = 0, xanchor = "left", yanchor = "top", xmargin = 0, ymargin = 0 } = {}) {
                this.#isopen = true;
                this.elem.hidden = false;
                this.elem.focus();

                const { width, height } = this.elem.getBoundingClientRect();
                if (x - width - xmargin < 0) xanchor = "left";
                if (x + width + xmargin > innerWidth) xanchor = "right";
                if (y - height - ymargin < 0) yanchor = "top";
                if (y + height + ymargin > innerHeight) yanchor = "bottom";

                if (xanchor === "left") {
                    this.elem.style.left = `${x + xmargin}px`;
                    this.elem.style.right = "";
                }
                else if (xanchor === "right") {
                    this.elem.style.left = "";
                    this.elem.style.right = `${innerWidth - x + xmargin}px`;
                }
                if (yanchor === "top") {
                    this.elem.style.top = `${y + ymargin}px`;
                    this.elem.style.bottom = "";
                }
                else if (yanchor === "bottom") {
                    this.elem.style.top = "";
                    this.elem.style.bottom = `${innerHeight - y + ymargin}px`;
                }
            }

            close() {
                this.elem.hidden = true;
                this.onclose?.();
            }
        };

        const Contextmenu = class extends Popup {
            constructor(props, ...children) {
                super(props, ...children);

                this.elem.classList.add("contextmenu");
            }
        };

        const Selectmenu = class extends Contextmenu {
            #value;
            #values;
            options = [];

            constructor({ values = [], defaultValue, onchange, autoclose = true, titleElem, props, ...rest } = {}) {
                super(props);

                this.elem.classList.add("selectmenu");
                Object.assign(this, { values, onchange, autoclose, titleElem, ...rest });
                
                this.value = defaultValue ?? (Array.isArray(values) ? values : Object.values(values))[0];
            }

            get value() {
                return this.#value;
            }

            set value(value) {
                this.#value = value;

                this.#update();
            }

            get values() {
                return this.#values;
            }

            set values(values) {
                this.#values = values;

                this.options.forEach(option => option.remove());

                if (Array.isArray(values)) {
                    this.options = values.map(value => createElement("button", {
                        innerHTML: value,
                        onclick: () => {
                            if (this.value === value) return;

                            this.value = value;
                            this.onchange?.();
                            if (this.autoclose) this.close();
                        },
                    }));
                }
                else {
                    this.options = Object.entries(values).map(([key, value]) => createElement("button", {
                        innerHTML: key,
                        onclick: () => {
                            if (this.value === value) return;

                            this.value = value;
                            this.onchange?.();
                            if (this.autoclose) this.close();
                        },
                    }));
                }

                this.elem.append(...Object.values(this.options));

                this.#update();
            }

            open(pos) {
                super.open(pos);

                const values = Array.isArray(this.values) ? this.values : Object.values(this.values);
                this.options[values.indexOf(this.value)]?.focus();
            }

            #update() {
                const keys = Array.isArray(this.values) ? undefined : Object.keys(this.values);
                const values = Array.isArray(this.values) ? this.values : Object.values(this.values);

                for (const i in values) {
                    if (values[i] === this.#value) {
                        this.options[i].classList.add("selected");

                        if (this.titleElem) {
                            if (keys) this.titleElem.innerHTML = keys[i];
                            else this.titleElem.innerHTML = this.#value;
                        }
                    }
                    else this.options[i].classList.remove("selected");
                }
            }
        };

        const Modal = class {
            elem;
            onclose;
            #background;

            constructor(props, ...children) {
                this.elem = createElement("div", props, ...children);
                this.elem.classList.add("modal");

                this.#background = createElement("div", {
                    style: {
                        position: "fixed",
                        inset: "0",
                        zIndex: "9999",

                        backdropFilter: "blur(4px) brightness(80%)",
                        display: "grid",
                        placeItems: "center",
                    },
                    hidden: true,
                    onmousedown: e => {
                        e.stopPropagation();
                        if (!this.elem.contains(e.target)) this.close();
                    },
                }, this.elem);
                
                $("body").append(this.#background);

                addEventListener("fullscreenchange", () => {
                    if (document.fullscreenElement) document.fullscreenElement.append(this.#background);
                    else $("body").append(this.#background);
                });
            }

            open() {
                this.#background.hidden = false;
            }

            close() {
                this.#background.hidden = true;
                this.onclose?.();
            }
        };

        const NamedForm = class {
            elem;
            form;
            #unitform;
            #value;
            #unit;
            #disabled = false;

            constructor(object) {
                Object.assign(this, object);
                
                this.elem = createElement("div", {
                    class: "namedform",

                    ...this.props,
                });

                if (this.type === "checkbox") {
                    this.form = createElement("input", {
                        type: "checkbox",
                        onchange: e => {
                            this.#value = this.form.checked;
                            this.onchange?.();
                        },

                        ...this.formprops,
                    });

                    this.elem.append(
                        createElement("label", { style: { fontWeight: "bold" } },
                            this.form,
                            this.lname ?? this.name ? createElement("span", {
                                title: this.description ?? this.name ?? "",
                                innerHTML: this.lname ?? this.name ?? "",

                                ...this.nameprops,
                            }) : "",
                        ),
                    );
                }

                else {
                    if (this.type === "select") {
                        this.form = createElement("select", {
                            class: "form",
                            required: this.required ?? true,
                            
                            onchange: e => {
                                this.#value = (
                                    Array.isArray(this.values) ? this.values[this.form.selectedIndex]
                                    : JSON.parse(this.form.value)
                                );
                                this.onchange?.();
                            },

                            ...this.formprops,
                        }, ...(
                            Array.isArray(this.values) ? this.values.map(option => createElement("option", null, option))
                            : Object.entries(this.values).map(
                                ([key, value]) => createElement("option", { value: JSON.stringify(value) }, key)
                            )
                        ));

                        this.#value = (
                            Array.isArray(this.values) ? this.values[this.form.selectedIndex]
                            : JSON.parse(this.form.value)
                        );
                    }
                    else {
                        this.form = createElement("input", {
                            class: "form",
                            required: this.required ?? true,

                            ...(this.type === "number" ? {
                                type: "number",
                                min: this.min,
                                max: this.max,
                                step: this.step ?? "any",
                                oninput: e => {
                                    this.#value = this.form.value === "" ? undefined : Number(this.form.value);
                                    this.onchange?.();
                                },
                            } : {
                                type: "text",
                                oninput: e => {
                                    this.#value = this.form.value;
                                    this.onchange?.();
                                },
                            }),

                            onkeydown: e => {
                                if (e.keyCode === 13) this.form.blur();
                            },
                            
                            ...this.formprops,
                        });
                        
                        if (this.values) {
                            const uuid = crypto.randomUUID();
                            
                            this.form.setAttribute("list", uuid);
                            this.datalist = createElement("datalist", { id: uuid },
                                ...this.values.map(option => createElement("option", null, option))
                            );

                            $("body").append(this.datalist);
                        }
                    }

                    if (this.units) {
                        this.#unitform = createElement("select", {
                            class: "unitform",
                            
                            onchange: e => {
                                this.#unit = Number(this.#unitform.value);
                                this.onchange?.();
                            },

                            ...this.unitformprops,
                        }, ...Object.entries(this.units).map(([key, value]) => createElement("option", { value }, key)));

                        if (this.defaultUnit) this.#unitform.value = this.units[this.defaultUnit];
                        this.#unit = Number(this.#unitform.value);
                    }

                    this.elem.append(
                        this.lname ?? this.name ? createElement("span", {
                            class: "name",
                            title: this.description ?? this.name ?? "",
                            innerHTML: this.lname ?? this.name,

                            ...this.nameprops,
                        }) : "",
                        this.form,
                        this.#unitform ?? "",
                    );
                }

                this.value = this.defaultValue;
            }

            get value() {
                if (typeof this.#value === "string" && this.#value) return this.#value;
                if (typeof this.#value === "number" && !isNaN(this.#value)) return this.#unit ? round(this.#value * this.#unit) : this.#value;
                return this.#value;
            }

            set value(value) {
                if (this.type === "checkbox") {
                    this.#value = value;
                    this.form.checked = value;
                }
                else if (this.type === "select") {
                    if (value === undefined) {
                        this.#value = undefined;
                        this.form.value = "";
                    }
                    else if (Array.isArray(this.values)) {
                        for (const _value of this.values) {
                            if (this.units) {
                                let done;

                                for (const unit of Object.values(this.units)) {
                                    if (round(_value * unit) === value) {
                                        this.#value = _value;
                                        this.#unit = unit;
                                        this.form.value = _value;
                                        this.#unitform.value = unit;

                                        done = true;
                                        break;
                                    }
                                }

                                if (done) break;
                            }
                            else {
                                if (_value === value) {
                                    this.#value = _value;
                                    this.form.value = _value;
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        const serialized = JSON.stringify(value);

                        for (const _value of Object.values(this.values)) {
                            const _serialized = JSON.stringify(_value);

                            if (_serialized === serialized) {
                                this.#value = _value;
                                this.form.value = _serialized;
                                break;
                            }
                        }
                    }
                }
                else if (this.type === "number") {
                    if (value === undefined) {
                        this.#value = undefined;
                        this.form.value = "";
                    }
                    else if (this.units) {
                        const { abs } = Math;
                        const unit = (
                            value === 0 ? this.units[this.defaultUnit]
                            : Object.values(this.units).find(unit => 1 <= abs(value / unit) && abs(value / unit) < 1000)
                        ) ?? Object.values(this.units).reduce(
                            (pre, cur) => abs(abs(value) - cur) < abs(abs(value) - pre) ? cur : pre
                        );

                        this.#value = value && round(value / unit);
                        this.#unit = unit;
                        this.form.value = value && round(value / unit);
                        this.#unitform.value = unit;
                    }
                    else {
                        this.#value = value;
                        this.form.value = value;
                    }
                }
                else {
                    this.#value = value;
                    this.form.value = value ?? "";
                }
            }

            get isValid() {
                return this.#disabled || this.form.validity.valid;
            }

            get disabled() {
                return this.#disabled;
            }

            set disabled(disabled) {
                this.#disabled = disabled;
                this.elem.inert = disabled;
            }
        };

        const undoManager = new class {
            #undoStack = [];
            #redoStack = [];

            constructor() {
                addEventListener("keydown", e => {
                    if ((isMac ? e.metaKey : e.ctrlKey) && e.key === "z") {
                        this.undo(this.#undoStack.at(-1));
                    }
                    else if ((isMac ? e.metaKey : e.ctrlKey) && (e.key === "y" || e.key === "Z")) {
                        this.redo(this.#redoStack.at(-1));
                    }
                });
            }

            addAction(action) {
                this.#undoStack.push(action);

                return action;
            }

            undo(action) {
                if (!this.#undoStack.includes(action)) return;

                this.#undoStack = this.#undoStack.filter(_action => _action !== action);
                
                action.undo();
                this.#redoStack.push(action);
            }

            redo(action) {
                if (!this.#redoStack.includes(action)) return;

                this.#redoStack = this.#redoStack.filter(_action => _action !== action);
                
                action.redo();
                this.#undoStack.push(action);
            }
        }();

        const logger = new class {
            #elem = createElement("div", { class: "logger" });
            #timerID = null;

            constructor() {
                $("body").append(this.#elem);

                addEventListener("keydown", e => {
                    if (e.key === "l") this.#show();
                });

                this.#elem.onmousemove = () => {
                    this.#show();
                };
            }

            log(content) {
                const line = createElement("div", { style: { padding: "4px 8px" } }, content);

                line.animate([
                    { backgroundColor: "var(--border)", easing: "ease-in" },
                    { backgroundColor: "" },
                ], { duration: 1600, fill: "forwards" });

                this.#elem.append(line);
                this.#elem.scrollTo({ top: this.#elem.scrollHeight, behavior: "smooth" });

                this.#show();
            }

            #show() {
                this.#elem.animate([
                    { easing: "cubic-bezier(0.34, 1.56, 0.64, 1)" },
                    { transform: "none" },
                ], { duration: 400, fill: "forwards" });

                clearTimeout(this.#timerID);
                this.#timerID = setTimeout(() => this.#hide(), 3000);
            }
            
            #hide() {
                this.#elem.animate([
                    { easing: "ease-in" },
                    { transform: "translateX(-150%)" },
                ], { duration: 600, fill: "forwards" });
            }
        }();

        const info = {
            params: {
                mode: {
                    noText: true,
                },

                I_start: {
                    name: "I_start",
                    lname: "I_{\\rm start}",
                    unit: "A",
                },
                I_stop: {
                    name: "I_stop",
                    lname: "I_{\\rm stop}",
                    unit: "A",
                },
                I_step: {
                    name: "I_step",
                    lname: "I_{\\rm step}",
                    unit: "A",
                },
                t_interval: {
                    name: "t_interval",
                    lname: "t_{\\rm interval}",
                    unit: "s",
                },
                
                R_I: {
                    name: "R_I",
                    lname: "R_{I}",
                    unit: "Ω",
                },

                t_interval_repeat: {
                    name: "t_interval_repeat",
                    lname: "t_{\\rm interval}",
                    unit: "s",
                },

                T_start: {
                    name: "T_start",
                    lname: "T_{\\rm start}",
                    unit: "K",
                },
                T_stop: {
                    name: "T_stop",
                    lname: "T_{\\rm stop}",
                    unit: "K",
                },
                T_step: {
                    name: "T_step",
                    lname: "T_{\\rm step}",
                    unit: "K",
                },
                t_interval_Tctrl: {
                    name: "t_interval_Tctrl",
                    lname: "t_{\\rm interval}",
                    unit: "s",
                },
                
                Ibias_start: {
                    name: "Ibias_start",
                    lname: "I_{\\rm start}",
                    unit: "A",
                },
                Ibias_stop: {
                    name: "Ibias_stop",
                    lname: "I_{\\rm stop}",
                    unit: "A",
                },
                Ibias_step: {
                    name: "Ibias_step",
                    lname: "I_{\\rm step}",
                    unit: "A",
                },
                t_interval_Ibias: {
                    name: "t_interval_Ibias",
                    lname: "t_{\\rm interval}",
                    unit: "s",
                },

                yokogawa7651_range: {
                    name: "yokogawa7651_range",
                    unit: "A",
                },

                Ic: {
                    name: "Ic",
                    unit: "A",
                },
                IcRn: {
                    name: "IcRn",
                    unit: "V",
                },
                Vg: {
                    name: "Vg",
                    unit: "A",
                },
                I_start_calc: {
                    name: "I_start",
                    unit: "A",
                },
                I_stop_calc: {
                    name: "I_stop",
                    unit: "A",
                },
                I_step_calc: {
                    name: "I_step",
                    unit: "A",
                },
                range_I_calc: {
                    name: "range_I",
                },
            },
            data: {
                V: {
                    name: "V",
                    lname: "V",
                    altname: "Voltage",
                    unit: "V",
                    plotgroup: 1,
                    noAnnotation: true,
                    noText: true,
                },
                I: {
                    name: "I",
                    lname: "I",
                    altname: "Current",
                    unit: "A",
                    plotgroup: 1,
                    noAnnotation: true,
                    noText: true,
                },
                t: {
                    name: "t",
                    lname: "t",
                    altname: "Time",
                    unit: "s",
                    plotgroup: 1,
                    noAnnotation: true,
                    noText: true,
                },
                date: {
                    name: "date",
                    lname: "{\\rm date}",
                    altname: "Date",
                    unit: "",
                    SIpow: 0,
                    plotgroup: 2,
                    noText: true,
                },
                T: {
                    name: "T",
                    lname: "T",
                    altname: "Temperature",
                    unit: "K",
                    plotgroup: 2,
                },
                Ibias: {
                    name: "Ibias",
                    lname: "I_{\\rm bias}",
                    altname: "Bias current",
                    unit: "A",
                    plotgroup: 2,
                },
                A: {
                    name: "A",
                    lname: "A",
                    altname: "Junction area",
                    unit: "m²",
                    SIpow: 2,
                    plotgroup: 2,
                },
                d: {
                    name: "d",
                    lname: "d",
                    altname: "Barrier thickness",
                    unit: "m",
                    plotgroup: 2,
                },
                Ic1: {
                    name: "Ic+",
                    lname: "I_{\\rm c}^{\\:+}",
                    altname: "Positive critical current",
                    unit: "A",
                    plotgroup: 2,
                },
                Ic2: {
                    name: "Ic-",
                    lname: "I_{\\rm c}^{\\:-}",
                    altname: "Negative critical current",
                    unit: "A",
                    plotgroup: 2,
                },
                Ic12: {
                    name: "Ic+,Ic-",
                    lname: "I_{\\rm c}",
                    altname: "Critical current",
                    selname: "I_{\\rm c}^{\\:+},{\\it I}_{\\rm c}^{\\:-}",
                    unit: "A",
                    plotgroup: 2,
                    noAnnotation: true,
                    noText: true,
                },
                Ic: {
                    name: "Ic",
                    lname: "I_{\\rm c}",
                    altname: "Critical current",
                    unit: "A",
                    plotgroup: 2,
                },
                Jc: {
                    name: "Jc",
                    lname: "J_{\\rm c}",
                    altname: "Critical current density",
                    unit: "A/cm²",
                    plotgroup: 2,
                },
                Rn: {
                    name: "Rn",
                    lname: "R_{\\rm N}",
                    altname: "Normal resistance",
                    unit: "Ω",
                    plotgroup: 2,
                },
                Rsg: {
                    name: "Rsg",
                    lname: "R_{\\rm sg}",
                    altname: "Subgap resistance",
                    unit: "Ω",
                    plotgroup: 2,
                },
                Q: {
                    name: "Q",
                    lname: "Q",
                    altname: "Quality factor",
                    unit: "",
                    SIpow: 0,
                    plotgroup: 2,
                },
                RnA: {
                    name: "RnA",
                    lname: "R_{\\rm N}A",
                    altname: "R<sub>N</sub>A product",
                    unit: "Ωcm²",
                    plotgroup: 2,
                },
                rho: {
                    name: "ρ",
                    lname: "\\rho",
                    altname: "Resistivity",
                    unit: "Ωcm",
                    plotgroup: 2,
                },
                IcRn: {
                    name: "IcRn",
                    lname: "I_{\\rm c}R_{\\rm N}",
                    altname: "I<sub>c</sub>R<sub>N</sub> product",
                    unit: "V",
                    plotgroup: 2,
                },
                dIdV: {
                    name: "dI/dV",
                    lname: "{\\rm d}{\\it I}/{\\rm d}{\\it V}",
                    altname: "Differential conductance",
                    unit: "Ω⁻¹",
                    SIpow: -1,
                    plotgroup: 1,
                    noAnnotation: true,
                    noText: true,
                },
                Vg: {
                    name: "Vg",
                    lname: "V_{\\rm g}",
                    altname: "Gap voltage",
                    unit: "V",
                    plotgroup: 2,
                },
                Ic_th: {
                    name: "Ic_th",
                    lname: "I_{\\rm c}^{\\rm \\:th}",
                    altname: "Theoretical critical current",
                    unit: "A",
                    plotgroup: 2,
                },
                Jc_th: {
                    name: "Jc_th",
                    lname: "J_{\\rm c}^{\\rm \\:th}",
                    altname: "Theoretical critical current density",
                    unit: "A/cm²",
                    plotgroup: 2,
                },
                beta_c: {
                    name: "βc",
                    lname: "\\beta_{\\rm c}",
                    altname: "McCumber parameter",
                    unit: "",
                    plotgroup: 2,
                },
                C: {
                    name: "C",
                    lname: "C",
                    altname: "Capacitance",
                    unit: "F",
                    plotgroup: 2,
                },
                Cs: {
                    name: "Cs",
                    lname: "C_{\\rm s}",
                    altname: "Specific capacitance",
                    unit: "F/m²",
                    plotgroup: 2,
                },
                eps: {
                    name: "ε",
                    lname: "\\epsilon",
                    altname: "Permittivity",
                    unit: "F/m",
                    plotgroup: 2,
                },
                eps_r: {
                    name: "εr",
                    lname: "\\epsilon_{\\rm r}",
                    altname: "Relative permittivity",
                    unit: "",
                    plotgroup: 2,
                },
            },
            calcparams: {
                Voffset: {
                    name: "Voffset",
                    lname: "V_{\\rm offset}",
                    unit: "V",
                    defaultValue: 0,
                },
                Ioffset: {
                    name: "Ioffset",
                    lname: "I_{\\rm offset}",
                    unit: "A",
                    defaultValue: 0,
                },
                V_Ic: {
                    name: "V_Ic",
                    lname: "V_{I_{\\rm c}}",
                    unit: "V",
                    defaultValue: 0.1e-3,
                },
                Vn: {
                    name: "Vn",
                    lname: "V_{\\rm n}",
                    unit: "V",
                    defaultValue: 10e-3,
                },
                Vsg: {
                    name: "Vsg",
                    lname: "V_{\\rm sg}",
                    unit: "V",
                    defaultValue: 3e-3,
                },
                Vg_min: {
                    name: "Vg_min",
                    lname: "V_{\\rm g,min}",
                    unit: "V",
                    defaultValue: 0.1e-3,
                },
                Vg_max: {
                    name: "Vg_max",
                    lname: "V_{\\rm g,max}",
                    unit: "V",
                    defaultValue: -0.1e-3,
                },
                N_SMA: {
                    name: "N_SMA",
                    lname: "N_{\\rm SMA}",
                    unit: "",
                    defaultValue: 50,
                },
            },
            fits: {
                "I-V": {
                    Ic: {
                        name: "Ic",
                        unit: "A",
                    },
                    IcRn: {
                        name: "IcRn",
                        unit: "V",
                    },
                    Vg: {
                        name: "Vg",
                        unit: "V",
                    },
                    Q: {
                        name: "Q",
                    },
                    n: {
                        name: "n",
                    },
                    beta_c: {
                        name: "βc",
                    },
                },
                "Ic-A": {
                    Jc: {
                        name: "Jc",
                        lname: "J_{\\rm c}",
                        unit: "A/cm²",
                    },
                    delta_a: {
                        name: "delta_a",
                        lname: "\\Delta a",
                        unit: "m",
                    },
                    lambda_J: {
                        name: "lambda_J",
                        lname: "\\lambda_{\\rm J}",
                        unit: "m",
                    },
                },
                "Ic_th-A": {
                    Jc_th: {
                        name: "Jc",
                        lname: "J_{\\rm c}^{\\rm th}",
                        unit: "A/cm²",
                    },
                    delta_a: {
                        name: "delta_a",
                        lname: "\\Delta a",
                        unit: "m",
                    },
                    lambda_J: {
                        name: "lambda_J",
                        lname: "\\lambda_{\\rm J}",
                        unit: "m",
                    },
                },
                "RnA-A": {
                    delta_a: {
                        name: "delta_a",
                        lname: "\\Delta a",
                        unit: "m",
                    },
                    RnA: {
                        name: "RnA",
                        lname: "R_{\\rm N}A",
                        unit: "Ωcm²",
                    },
                },
                "Ic12-Ibias": {
                    deltaI: {
                        name: "deltaI",
                        lname: "\\Delta I",
                        unit: "A",
                    },
                    Ioffset: {
                        name: "Ioffset",
                        lname: "I_{\\rm offset}",
                        unit: "A",
                    },
                    L: {
                        name: "L",
                        lname: "L",
                        unit: "H",
                    },
                    L1: {
                        name: "L1",
                        lname: "L_{\\rm 1}",
                        unit: "H",
                    },
                    L2: {
                        name: "L2",
                        lname: "L_{\\rm 2}",
                        unit: "H",
                    },
                    Ic: {
                        name: "Ic",
                        lname: "I_{\\rm c}",
                        unit: "A",
                    },
                    Ic1: {
                        name: "Ic1",
                        lname: "I_{\\rm c1}",
                        unit: "A",
                    },
                    Ic2: {
                        name: "Ic2",
                        lname: "I_{\\rm c2}",
                        unit: "A",
                    },
                },
            },
        };

        const measurement = new class {
            #elem = $("#measurement");
            #title = createElement("h2");
            #modeSelector = new Selectmenu({
                titleElem: this.#title,
                values: {
                    "測定": "measure",
                    "計算": "calculate",
                },
                style: { fontSize: "1.2em" },
                onchange: () => {
                    this.mode = this.#modeSelector.value;
                },
            });
            #params = new class {
                elem = createElement("div", {
                    style: {
                        flexGrow: "1",
                        overflowY: "auto",
                    },
                });
                deviceButton = createElement("button", {
                    class: "icon",
                    style: { marginLeft: "auto" },
                    title: "デバイス設定を開く",
                    innerHTML: '<svg width="15" height="15" viewBox="0 0 512 512" fill="currentColor"><path d="M256,176a80,80,0,1,0,80,80A80.24,80.24,0,0,0,256,176Zm172.72,80a165.53,165.53,0,0,1-1.64,22.34l48.69,38.12a11.59,11.59,0,0,1,2.63,14.78l-46.06,79.52a11.64,11.64,0,0,1-14.14,4.93l-57.25-23a176.56,176.56,0,0,1-38.82,22.67l-8.56,60.78A11.93,11.93,0,0,1,302.06,486H209.94a12,12,0,0,1-11.51-9.53l-8.56-60.78A169.3,169.3,0,0,1,151.05,393L93.8,416a11.64,11.64,0,0,1-14.14-4.92L33.6,331.57a11.59,11.59,0,0,1,2.63-14.78l48.69-38.12A174.58,174.58,0,0,1,83.28,256a165.53,165.53,0,0,1,1.64-22.34L36.23,195.54a11.59,11.59,0,0,1-2.63-14.78l46.06-79.52A11.64,11.64,0,0,1,93.8,96.31l57.25,23a176.56,176.56,0,0,1,38.82-22.67l8.56-60.78A11.93,11.93,0,0,1,209.94,26h92.12a12,12,0,0,1,11.51,9.53l8.56,60.78A169.3,169.3,0,0,1,361,119L418.2,96a11.64,11.64,0,0,1,14.14,4.92l46.06,79.52a11.59,11.59,0,0,1-2.63,14.78l-48.69,38.12A174.58,174.58,0,0,1,428.72,256Z"/></svg>',
                    onclick: () => {
                        this.#deviceModal.open();
                    },
                });
                #deviceModal = new Modal({ style: { width: "500px", padding: "8px 12px" } },
                    createElement("div", { class: "align-center", style: { width: "100%", marginBottom: "8px" } },
                        createElement("h2", null, "デバイス設定"),
                        createElement("button", {
                            class: "icon",
                            style: { marginLeft: "auto" },
                            title: "デバイスリスト(入力欄のサジェスト)を更新",
                            innerHTML: '<svg width="15" height="15" viewbox="0 0 10 10" fill="none" stroke="currentColor"><path d="M 8 4 a 3.5 3.5 0 1 0 0 2"/><path d="M 8.5 1 v 3 h -3"/></svg>',
                            onclick: () => this.#refreshDevicelist(),
                        }),
                    ),
                );
                formulaButton = createElement("button", {
                    style: { marginLeft: "auto", fontSize: "0.75em" },
                    title: "数式を表示",
                    onclick: () => {
                        this.#formulaModal.open();
                    },
                }, "数式");
                #formulaModal = new Modal({ style: { padding: "12px 16px" } },
                    createElement("h3", null, "RSJ"),
                    createElement("div", {
                        style: { width: "min-content", padding: "0 16px" },
                        innerHTML: String.raw`$$ I=I_{\rm c} \sin \theta + \frac{\dot \theta}{R_{\rm N}} + C \ddot \theta $$`,
                    }),
                    createElement("h3", null, "RSJN"),
                    createElement("div", {
                        style: { width: "min-content", padding: "0 16px" },
                        innerHTML: String.raw`$$ I=I_{\rm c} \sin \theta + \frac{\dot \theta}{R_{\rm N}} \frac{( \dot \theta / V_{\rm g} ) ^ n}{1 + ( \dot \theta / V_{\rm g} ) ^ n} + C \ddot \theta $$`,
                    }),
                    createElement("h3", null, "TJM"),
                    createElement("a", {
                        href: "https://doi.org/10.1103/PhysRev.147.255",
                        referrerpolicy: "no-referrer",
                        target: "_blank",
                    }, "N. R. Werthamer, Phys. Rev. 147(1), 255, 1966."),

                    createElement("h5", { style: { marginTop: "20px" } }, "※参考"),
                    createElement("a", {
                        href: "http://pscan2sim.org/Windows/PSCAN2_UserGuide_ak.pdf",
                        referrerpolicy: "no-referrer",
                        target: "_blank",
                    }, "http://pscan2sim.org/Windows/PSCAN2_UserGuide_ak.pdf")
                );
                measforms = {
                    common1: {
                        measurement_system: new NamedForm({
                            name: "measurement_system",
                            lname: "測定系",
                            type: "select",
                            values: [
                                "直流",
                                "交流",
                            ],
                            defaultValue: "交流",
                            onchange: () => this.#onchange(),
                        }),
                    },
                    dc: {
                        current_source: new NamedForm({
                            name: "current_source",
                            lname: "電流源",
                            type: "select",
                            values: [
                                "Keithley2400",
                                "Yokogawa7651",
                            ],
                            defaultValue: "Keithley2400",
                            onchange: () => this.#onchange(),
                        }),
                        voltage_meter: new NamedForm({
                            name: "voltage_meter",
                            lname: "電圧計",
                            type: "select",
                            values: [
                                "Keithley2400",
                                "Keysight34420A",
                            ],
                            defaultValue: "Keithley2400",
                            onchange: () => this.#onchange(),
                        }),
                        I_start: new NamedForm({
                            name: "I_start",
                            lname: "$I_{\\rm start}$",
                            type: "number",
                            units: {
                                "mA": 1e-3,
                                "μA": 1e-6,
                                "nA": 1e-9,
                            },
                            defaultValue: 0,
                            defaultUnit: "μA",
                            onchange: () => this.#onchange(),
                        }),
                        I_stop: new NamedForm({
                            name: "I_stop",
                            lname: "$I_{\\rm stop}$",
                            type: "number",
                            units: {
                                "mA": 1e-3,
                                "μA": 1e-6,
                                "nA": 1e-9,
                            },
                            defaultValue: 1000e-6,
                            defaultUnit: "μA",
                            onchange: () => this.#onchange(),
                        }),
                        I_step: new NamedForm({
                            name: "I_step",
                            lname: "$I_{\\rm step}$",
                            type: "number",
                            units: {
                                "mA": 1e-3,
                                "μA": 1e-6,
                                "nA": 1e-9,
                            },
                            defaultValue: 10e-6,
                            defaultUnit: "μA",
                            onchange: () => this.#onchange(),
                        }),
                        range_I: new NamedForm({
                            name: "range_I",
                            lname: "範囲",
                            description: "range_I\n1 direction: start → stop\nHalf region: start → stop → start\nAll region: start → stop → -stop → start",
                            type: "select",
                            values: [
                                "1 direction",
                                "1 direction x2",
                                "1 direction x3",
                                "Half region",
                                "Half region x2",
                                "Half region x3",
                                "All region",
                                "All region x2",
                                "All region x3",
                            ],
                            defaultValue: "All region",
                            onchange: () => this.#onchange(),
                        }),
                        t_interval: new NamedForm({
                            name: "t_interval",
                            lname: "$t_{\\rm interval}$",
                            type: "number",
                            units: {
                                "s": 1,
                                "ms": 1e-3,
                            },
                            defaultValue: 50e-3,
                            onchange: () => this.#onchange(),
                        }),
                        delta_measurement: new NamedForm({
                            name: "delta_measurement",
                            lname: "熱起電力キャンセル",
                            type: "checkbox",
                            defaultValue: false,
                            onchange: () => this.#onchange(),
                        }),
                    },
                    ac: {
                        points: new NamedForm({
                            name: "points",
                            lname: "points",
                            type: "select",
                            values: [
                                100, 250, 500, 1000, 2000, 5000, 10000, 20000, 50000, 62500,
                            ],
                            defaultValue: 10000,
                            onchange: () => this.#onchange(),
                        }),
                        channel_I: new NamedForm({
                            name: "channel_I",
                            lname: "Ch $I$",
                            type: "select",
                            values: [
                                "Ch1",
                                "Ch2",
                                "Ch3",
                                "Ch4",
                                "Ch1-Ch2",
                                "Ch1-Ch3",
                                "Ch1-Ch4",
                                "Ch2-Ch1",
                                "Ch2-Ch3",
                                "Ch2-Ch4",
                                "Ch3-Ch1",
                                "Ch3-Ch2",
                                "Ch3-Ch4",
                                "Ch4-Ch1",
                                "Ch4-Ch2",
                                "Ch4-Ch3",
                            ],
                            defaultValue: "Ch1",
                            onchange: () => this.#onchange(),
                        }),
                        channel_V: new NamedForm({
                            name: "channel_V",
                            lname: "Ch $V$",
                            type: "select",
                            values: [
                                "Ch1",
                                "Ch2",
                                "Ch3",
                                "Ch4",
                                "Ch1-Ch2",
                                "Ch1-Ch3",
                                "Ch1-Ch4",
                                "Ch2-Ch1",
                                "Ch2-Ch3",
                                "Ch2-Ch4",
                                "Ch3-Ch1",
                                "Ch3-Ch2",
                                "Ch3-Ch4",
                                "Ch4-Ch1",
                                "Ch4-Ch2",
                                "Ch4-Ch3",
                            ],
                            defaultValue: "Ch2",
                            onchange: () => this.#onchange(),
                        }),
                        Gain_I: new NamedForm({
                            name: "Gain_I",
                            lname: "Gain $I$",
                            type: "select",
                            values: [
                                1, 2, 5,
                            ],
                            units: {
                                "x1": 1,
                                "x10": 10,
                                "x10²": 100,
                                "x10³": 1000,
                            },
                            defaultValue: 1,
                            onchange: () => this.#onchange(),
                        }),
                        Gain_V: new NamedForm({
                            name: "Gain_V",
                            lname: "Gain $V$",
                            type: "select",
                            values: [
                                1, 2, 5,
                            ],
                            units: {
                                "x1": 1,
                                "x10": 10,
                                "x10²": 100,
                                "x10³": 1000,
                            },
                            defaultValue: 100,
                            onchange: () => this.#onchange(),
                        }),
                        R_I: new NamedForm({
                            name: "R_I",
                            lname: "$R_{I}$",
                            type: "number",
                            units: {
                                "kΩ": 1e3,
                                "Ω": 1,
                            },
                            defaultValue: 1000,
                            onchange: () => this.#onchange(),
                        }),
                    },
                    common2: {
                        repeat: new NamedForm({
                            name: "repeat",
                            lname: "繰り返し",
                            type: "checkbox",
                            defaultValue: false,
                            onchange: () => {
                                const { repeat, temperature_control, current_bias } = this.measforms.common2;
                                if (repeat.value) {
                                    temperature_control.value = false;
                                    current_bias.value = false;
                                }

                                this.#onchange();
                            },
                        }),
                        repeats: new NamedForm({
                            name: "repeats",
                            lname: "回数",
                            type: "number",
                            step: 1,
                            min: 1,
                            defaultValue: 100,
                            onchange: () => this.#onchange(),
                        }),
                        t_interval_repeat: new NamedForm({
                            name: "t_interval_repeat",
                            lname: "$t_{\\rm interval}$",
                            type: "number",
                            units: {
                                "s": 1,
                                "ms": 1e-3,
                            },
                            defaultValue: 0.5,
                            onchange: () => this.#onchange(),
                        }),

                        temperature_control: new NamedForm({
                            name: "temperature_control",
                            lname: "温調",
                            type: "checkbox",
                            defaultValue: false,
                            onchange: () => {
                                const { repeat, temperature_control, current_bias } = this.measforms.common2;
                                if (temperature_control.value) {
                                    repeat.value = false;
                                    current_bias.value = false;
                                }

                                this.#onchange();
                            },
                        }),
                        T_start: new NamedForm({
                            name: "T_start",
                            lname: "$T_{\\rm start}$",
                            type: "number",
                            units: {
                                "K": 1,
                                "mK": 1e-3,
                            },
                            defaultValue: 2.5,
                            onchange: () => this.#onchange(),
                        }),
                        T_stop: new NamedForm({
                            name: "T_stop",
                            lname: "$T_{\\rm stop}$",
                            type: "number",
                            units: {
                                "K": 1,
                                "mK": 1e-3,
                            },
                            defaultValue: 12,
                            onchange: () => this.#onchange(),
                        }),
                        T_step: new NamedForm({
                            name: "T_step",
                            lname: "$T_{\\rm step}$",
                            type: "number",
                            units: {
                                "K": 1,
                                "mK": 1e-3,
                            },
                            defaultValue: 0.5,
                            onchange: () => this.#onchange(),
                        }),
                        t_interval_Tctrl: new NamedForm({
                            name: "t_interval_Tctrl",
                            lname: "$t_{\\rm interval}$",
                            type: "number",
                            units: {
                                "s": 1,
                                "ms": 1e-3,
                            },
                            defaultValue: 60,
                            onchange: () => this.#onchange(),
                        }),
                        
                        current_bias: new NamedForm({
                            name: "current_bias",
                            lname: "磁場変調",
                            type: "checkbox",
                            defaultValue: false,
                            onchange: () => {
                                const { repeat, temperature_control, current_bias } = this.measforms.common2;
                                if (current_bias.value) {
                                    repeat.value = false;
                                    temperature_control.value = false;
                                }

                                this.#onchange();
                            },
                        }),
                        bias_current_source: new NamedForm({
                            name: "bias_current_source",
                            lname: "電流源",
                            type: "select",
                            values: [
                                "Keithley2400",
                                "Yokogawa7651",
                            ],
                            defaultValue: "Keithley2400",
                            onchange: () => this.#onchange(),
                        }),
                        Ibias_start: new NamedForm({
                            name: "Ibias_start",
                            lname: "$I_{\\rm start}$",
                            type: "number",
                            units: {
                                "mA": 1e-3,
                                "μA": 1e-6,
                                "nA": 1e-9,
                            },
                            defaultValue: 0,
                            defaultUnit: "μA",
                            onchange: () => this.#onchange(),
                        }),
                        Ibias_stop: new NamedForm({
                            name: "Ibias_stop",
                            lname: "$I_{\\rm stop}$",
                            type: "number",
                            units: {
                                "mA": 1e-3,
                                "μA": 1e-6,
                                "nA": 1e-9,
                            },
                            defaultValue: 10e-6,
                            defaultUnit: "μA",
                            onchange: () => this.#onchange(),
                        }),
                        Ibias_step: new NamedForm({
                            name: "Ibias_step",
                            lname: "$I_{\\rm step}$",
                            type: "number",
                            units: {
                                "mA": 1e-3,
                                "μA": 1e-6,
                                "nA": 1e-9,
                            },
                            defaultValue: 1e-6,
                            defaultUnit: "μA",
                            onchange: () => this.#onchange(),
                        }),
                        range_Ibias: new NamedForm({
                            name: "range_Ibias",
                            lname: "範囲",
                            description: "range_Ibias\n1 direction: start → stop\nHalf region: start → stop → start\nAll region: start → stop → -stop → start",
                            type: "select",
                            values: [
                                "1 direction",
                                "1 direction x2",
                                "1 direction x3",
                                "Half region",
                                "Half region x2",
                                "Half region x3",
                                "All region",
                                "All region x2",
                                "All region x3",
                            ],
                            defaultValue: "All region",
                            onchange: () => this.#onchange(),
                        }),
                        t_interval_Ibias: new NamedForm({
                            name: "t_interval_Ibias",
                            lname: "$t_{\\rm interval}$",
                            type: "number",
                            units: {
                                "s": 1,
                                "ms": 1e-3,
                            },
                            defaultValue: 0.5,
                            onchange: () => this.#onchange(),
                        }),
                    },
                };
                deviceforms = {
                    use_lakeshore335: new NamedForm({
                        name: "use_lakeshore335",
                        lname: "Lakeshore335を使う",
                        type: "checkbox",
                        defaultValue: true,
                        onchange: () => this.#onchange(),
                        nameprops: { style: { width: "180px" } },
                    }),
                    lakeshore335_address: new NamedForm({
                        name: "lakeshore335_address",
                        lname: "Lakeshore335",
                        type: "text",
                        values: [],
                        defaultValue: "GPIB0::12::INSTR",
                        onchange: () => this.#onchange(),
                        nameprops: { style: { width: "180px" } },
                    }),
                    keysightDSOX1204A_address: new NamedForm({
                        name: "keysightDSOX1204A_address",
                        lname: "KeysightDSOX1204A",
                        type: "text",
                        values: [],
                        defaultValue: "USB0::0x2A8D::0x0386::CN58476227::INSTR",
                        onchange: () => this.#onchange(),
                        nameprops: { style: { width: "180px" } },
                    }),
                    keithley2400_address: new NamedForm({
                        name: "keithley2400_address",
                        lname: "Keithley2400",
                        type: "text",
                        values: [],
                        defaultValue: "GPIB0::18::INSTR",
                        onchange: () => this.#onchange(),
                        nameprops: { style: { width: "180px" } },
                    }),
                    keithley2400_terminal: new NamedForm({
                        name: "keithley2400_terminal",
                        lname: "Terminal",
                        type: "select",
                        values: [
                            "Front", "Rear"
                        ],
                        defaultValue: "Front",
                        onchange: () => this.#onchange(),
                        nameprops: { style: { width: "180px", paddingLeft: "16px" } },
                    }),
                    yokogawa7651_address: new NamedForm({
                        name: "yokogawa7651_address",
                        lname: "Yokogawa7651",
                        type: "text",
                        values: [],
                        defaultValue: "GPIB0::7::INSTR",
                        onchange: () => this.#onchange(),
                        nameprops: { style: { width: "180px" } },
                    }),
                    yokogawa7651_range: new NamedForm({
                        name: "yokogawa7651_range",
                        lname: "Range",
                        type: "select",
                        values: {
                            "1mA": 1e-3,
                            "10mA": 10e-3,
                            "100mA": 100e-3,
                        },
                        defaultValue: 100e-3,
                        onchange: () => this.#onchange(),
                        nameprops: { style: { width: "180px", paddingLeft: "16px" } },
                    }),
                    keysight34420A_address: new NamedForm({
                        name: "keysight34420A_address",
                        lname: "Keysight34420A",
                        type: "text",
                        values: [],
                        defaultValue: "GPIB0::22::INSTR",
                        onchange: () => this.#onchange(),
                        nameprops: { style: { width: "180px" } },
                    }),
                    keysight34420A_NPLC: new NamedForm({
                        name: "keysight34420A_NPLC",
                        lname: "NPLC",
                        type: "select",
                        values: [0.1, 0.2, 0.5, 1, 2, 5, 10],
                        defaultValue: 1,
                        onchange: () => this.#onchange(),
                        nameprops: { style: { width: "180px", paddingLeft: "16px" } },
                    }),
                };
                calcforms = {
                    model: new NamedForm({
                        name: "model",
                        lname: "モデル",
                        type: "select",
                        values: [
                            "RSJ",
                            "RSJN",
                            "TJM",
                        ],
                        defaultValue: "RSJ",
                        onchange: () => this.#onchange(),
                    }),
                    T: new NamedForm({
                        name: "T",
                        lname: "$T$",
                        type: "number",
                        units: {
                            "K": 1,
                            "mK": 1e-3,
                        },
                        defaultValue: 2.3,
                        onchange: () => this.#onchange(),
                    }),
                    delta_sm: new NamedForm({
                        name: "delta_sm",
                        lname: "$\\delta_{\\rm sm}$",
                        description: "Smearing of the Riedel peaks",
                        type: "number",
                        defaultValue: 0.015,
                        onchange: () => this.#onchange(),
                    }),
                    Ic: new NamedForm({
                        name: "Ic",
                        lname: "$I_{\\rm c}$",
                        type: "number",
                        units: {
                            "mA": 1e-3,
                            "μA": 1e-6,
                            "nA": 1e-9,
                        },
                        defaultValue: 100e-6,
                        onchange: () => this.#onchange(),
                    }),
                    IcRn: new NamedForm({
                        name: "IcRn",
                        lname: "$I_{\\rm c} R_{\\rm N}$",
                        type: "number",
                        units: {
                            "mV": 1e-3,
                            "μV": 1e-6,
                            "nV": 1e-9,
                        },
                        defaultValue: 4.4e-3,
                        onchange: () => this.#onchange(),
                    }),
                    Vg: new NamedForm({
                        name: "Vg",
                        lname: "$V_{\\rm g}$",
                        type: "number",
                        units: {
                            "mV": 1e-3,
                            "μV": 1e-6,
                            "nV": 1e-9,
                        },
                        defaultValue: 5.6e-3,
                        onchange: () => this.#onchange(),
                    }),
                    Vg_plus: new NamedForm({
                        name: "Vg_plus",
                        lname: "$V_{\\rm g}^{+}$",
                        type: "number",
                        units: {
                            "mV": 1e-3,
                            "μV": 1e-6,
                            "nV": 1e-9,
                        },
                        defaultValue: 5.6e-3,
                        defaultUnit: "mV",
                        onchange: () => this.#onchange(),
                    }),
                    Vg_minus: new NamedForm({
                        name: "Vg_minus",
                        lname: "$V_{\\rm g}^{-}$",
                        type: "number",
                        units: {
                            "mV": 1e-3,
                            "μV": 1e-6,
                            "nV": 1e-9,
                        },
                        defaultValue: 0,
                        defaultUnit: "mV",
                        onchange: () => this.#onchange(),
                    }),
                    n: new NamedForm({
                        name: "n",
                        lname: "$n$",
                        type: "number",
                        step: 2,
                        min: 0,
                        defaultValue: 10,
                        onchange: () => this.#onchange(),
                    }),
                    Q: new NamedForm({
                        name: "Q",
                        lname: "$Q$",
                        type: "number",
                        defaultValue: 10,
                        onchange: () => this.#onchange(),
                    }),
                    beta_c: new NamedForm({
                        name: "beta_c",
                        lname: "$\\beta_{\\rm c}$",
                        type: "number",
                        defaultValue: 10,
                        onchange: () => this.#onchange(),
                    }),
                    asymmetric: new NamedForm({
                        name: "asymmetric",
                        lname: "非対称なギャップ",
                        type: "checkbox",
                        defaultValue: false,
                        onchange: () => this.#onchange(),
                    }),
                    I_start_calc: new NamedForm({
                        name: "I_start_calc",
                        lname: "$I_{\\rm start}$",
                        type: "number",
                        units: {
                            "mA": 1e-3,
                            "μA": 1e-6,
                            "nA": 1e-9,
                        },
                        defaultValue: 0,
                        defaultUnit: "μA",
                        props: { style: { marginTop: "0.25em", paddingTop: "0.25em", borderTop: "1px solid var(--border)" } },
                        onchange: () => this.#onchange(),
                    }),
                    I_stop_calc: new NamedForm({
                        name: "I_stop_calc",
                        lname: "$I_{\\rm stop}$",
                        type: "number",
                        units: {
                            "mA": 1e-3,
                            "μA": 1e-6,
                            "nA": 1e-9,
                        },
                        defaultValue: 200e-6,
                        defaultUnit: "μA",
                        onchange: () => this.#onchange(),
                    }),
                    I_step_calc: new NamedForm({
                        name: "I_step_calc",
                        lname: "$I_{\\rm step}$",
                        type: "number",
                        units: {
                            "mA": 1e-3,
                            "μA": 1e-6,
                            "nA": 1e-9,
                        },
                        defaultValue: 10e-6,
                        defaultUnit: "μA",
                        onchange: () => this.#onchange(),
                    }),
                    range_I_calc: new NamedForm({
                        name: "range_I_calc",
                        lname: "範囲",
                        description: "range_I\n1 direction: start → stop\nHalf region: start → stop → start\nAll region: start → stop → -stop → start",
                        type: "select",
                        values: [
                            "1 direction",
                            "Half region",
                            "All region",
                        ],
                        defaultValue: "All region",
                        onchange: () => this.#onchange(),
                    }),
                    epsilon: new NamedForm({
                        name: "epsilon",
                        lname: "許容誤差",
                        type: "number",
                        defaultValue: 1e-8,
                        nameprops: { style: { fontSize: "0.9em" } },
                        onchange: () => this.#onchange(),
                    }),
                    t_wait: new NamedForm({
                        name: "t_wait",
                        lname: "$t_{\\rm wait}$",
                        type: "number",
                        units: {
                            "ms": 1e-3,
                            "μs": 1e-6,
                            "ns": 1e-9,
                            "ps": 1e-12,
                            "fs": 1e-15,
                        },
                        defaultValue: 1e-12,
                        defaultUnit: "ps",
                        onchange: () => this.#onchange(),
                    }),
                    t_min: new NamedForm({
                        name: "t_min",
                        lname: "$t_{\\rm min}$",
                        type: "number",
                        units: {
                            "ms": 1e-3,
                            "μs": 1e-6,
                            "ns": 1e-9,
                            "ps": 1e-12,
                            "fs": 1e-15,
                        },
                        defaultValue: 0,
                        defaultUnit: "ps",
                        onchange: () => this.#onchange(),
                    }),
                    t_max: new NamedForm({
                        name: "t_max",
                        lname: "$t_{\\rm max}$",
                        type: "number",
                        units: {
                            "ms": 1e-3,
                            "μs": 1e-6,
                            "ns": 1e-9,
                            "ps": 1e-12,
                            "fs": 1e-15,
                        },
                        defaultValue: 5e-12,
                        defaultUnit: "ps",
                        onchange: () => this.#onchange(),
                    }),
                    streaming: new NamedForm({
                        name: "streaming",
                        lname: "結果をリアルタイムで取得",
                        type: "checkbox",
                        defaultValue: true,
                    }),
                };
                #mode;
                
                constructor() {
                    this.elem.append(
                        ...Object.values({
                            ...this.measforms.common1,
                            ...this.measforms.dc,
                            ...this.measforms.ac,
                            ...this.measforms.common2,
                            ...this.calcforms,
                        }).map(({ elem }) => elem),
                    );

                    this.#deviceModal.elem.append(
                        ...Object.values({
                            ...this.deviceforms,
                        }).map(({ elem }) => elem),
                    );
                }

                get mode() {
                    return this.#mode;
                }

                set mode(mode) {
                    this.#mode = mode;

                    this.deviceButton.hidden = mode !== "measure";
                    this.formulaButton.hidden = mode !== "calculate";

                    for (const form of Object.values({
                        ...this.measforms.common1,
                        ...this.measforms.dc,
                        ...this.measforms.ac,
                        ...this.measforms.common2,
                        ...this.deviceforms,
                    })) {
                        form.disabled = mode !== "measure";
                        form.elem.hidden = mode !== "measure";
                    }

                    for (const form of Object.values(this.calcforms)) {
                        form.disabled = mode !== "calculate";
                        form.elem.hidden = mode !== "calculate";
                    }

                    this.#update();
                }
                
                get #list() {
                    return Object.values({
                        ...this.measforms.common1,
                        ...this.measforms.dc,
                        ...this.measforms.ac,
                        ...this.measforms.common2,
                        ...this.calcforms,
                        ...this.deviceforms,
                    });
                }

                toObject({ onlyEnabled = true } = {}) {
                    const list = onlyEnabled ? this.#list.filter(({ disabled }) => !disabled) : this.#list;

                    return Object.fromEntries(list.map(({ name, value }) => [name, value]));
                }

                fromObject(object) {
                    for (const form of this.#list) {
                        if (form.name in object) form.value = object[form.name];
                    }

                    this.#onchange();
                }

                isValid() {
                    return this.#list.filter(({ disabled }) => !disabled).every(({ isValid }) => isValid);
                }

                #update() {
                    if (this.mode === "measure") {
                        const { measurement_system } = this.measforms.common1;

                        for (const form of Object.values(this.measforms.dc)) {
                            form.disabled = measurement_system.value !== "直流";
                            form.elem.hidden = measurement_system.value !== "直流";
                        }
                        for (const form of Object.values(this.measforms.ac)) {
                            form.disabled = measurement_system.value !== "交流";
                            form.elem.hidden = measurement_system.value !== "交流";
                        }

                        const { repeat, temperature_control, current_bias } = this.measforms.common2;
                        const { use_lakeshore335 } = this.deviceforms;

                        for (const form of Object.values(this.measforms.common2)) {
                            form.disabled = false;
                            form.elem.hidden = false;
                        }

                        if (!repeat.value) {
                            const { repeats, t_interval_repeat } = this.measforms.common2;

                            for (const form of [repeats, t_interval_repeat]) {
                                form.disabled = true;
                                form.elem.hidden = true;
                            }
                        }
                        if (!temperature_control.value || !use_lakeshore335.value) {
                            const { T_start, T_stop, T_step, t_interval_Tctrl } = this.measforms.common2;
                            
                            for (const form of [T_start, T_stop, T_step, t_interval_Tctrl]) {
                                form.disabled = true;
                                form.elem.hidden = true;
                            }

                            if (!use_lakeshore335.value) temperature_control.disabled = true;
                        }
                        if (!current_bias.value) {
                            const { bias_current_source, Ibias_start, Ibias_stop, Ibias_step, range_Ibias, t_interval_Ibias } = this.measforms.common2;
                            
                            for (const form of [bias_current_source, Ibias_start, Ibias_stop, Ibias_step, range_Ibias, t_interval_Ibias]) {
                                form.disabled = true;
                                form.elem.hidden = true;
                            }
                        }

                        const devices= [];
                        const {
                            lakeshore335_address,
                            keysightDSOX1204A_address,
                            keithley2400_address,
                            keithley2400_terminal,
                            yokogawa7651_address,
                            yokogawa7651_range,
                            keysight34420A_address,
                            keysight34420A_NPLC,
                        } = this.deviceforms;

                        if (use_lakeshore335.value) devices.push("Lakeshore335");
                        if (measurement_system.value === "直流") {
                            const { current_source, voltage_meter } = this.measforms.dc;
                            devices.push(current_source.value, voltage_meter.value);
                        }
                        else {
                            devices.push("KeysightDSOX1204A");
                        }
                        const { bias_current_source } = this.measforms.common2;
                        if (current_bias.value) devices.push(bias_current_source.value);

                        lakeshore335_address.disabled = !devices.includes("Lakeshore335");
                        keysightDSOX1204A_address.disabled = !devices.includes("KeysightDSOX1204A");
                        keithley2400_address.disabled = !devices.includes("Keithley2400");
                        keithley2400_terminal.disabled = !devices.includes("Keithley2400");
                        yokogawa7651_address.disabled = !devices.includes("Yokogawa7651");
                        yokogawa7651_range.disabled = !devices.includes("Yokogawa7651");
                        keysight34420A_address.disabled = !devices.includes("Keysight34420A");
                        keysight34420A_NPLC.disabled = !devices.includes("Keysight34420A");
                    }
                    else if (this.mode === "calculate") {
                        const setHidden = (form, value) => {
                            form.disabled = value;
                            form.elem.hidden = value;
                        };
                        const { model, T, delta_sm, Vg, Vg_plus, Vg_minus, n, Q, asymmetric } = this.calcforms;

                        setHidden(T, model.value !== "TJM");
                        setHidden(delta_sm, model.value !== "TJM");
                        setHidden(Vg, !(model.value === "RSJN" || model.value === "TJM" && !asymmetric.value));
                        setHidden(Vg_plus, !(model.value === "TJM" && asymmetric.value));
                        setHidden(Vg_minus, !(model.value === "TJM" && asymmetric.value));
                        setHidden(n, model.value !== "RSJN");
                        setHidden(Q, model.value !== "TJM");
                        setHidden(asymmetric, model.value !== "TJM");
                    }
                }

                #onchange() {
                    this.#update();
                    measurement.#execbutton.update();
                }

                async #refreshDevicelist() {
                    const devicelist = await (await fetch("/device_list")).json();
                
                    const {
                        lakeshore335_address,
                        keysightDSOX1204A_address,
                        keithley2400_address,
                        yokogawa7651_address,
                        keysight34420A_address,
                    } = this.deviceforms;

                    for (const form of [
                        lakeshore335_address,
                        keysightDSOX1204A_address,
                        keithley2400_address,
                        yokogawa7651_address,
                        keysight34420A_address,
                    ]) {
                        form.values = devicelist;

                        while (form.datalist.firstChild) form.datalist.firstChild.remove();
                        form.datalist.append(...devicelist.map(device => createElement("option", null, device)));
                    }
                }
            }();
            #execbutton = createElement("button", {
                id: "measurement-button",
                class: "large",
                style: { flexShrink: "0" },
                title: "測定の実行/停止(Ctrl+Enter)",
                onclick: () => this.#exec(),
                update: () => {
                    if (this.running) return;

                    this.#execbutton.inert = !this.#params.isValid();
                },
            }, "実行");
            #spinner = createElement("div", {
                class: "spinner",
                style: { flexShrink: "0" },
                hidden: true,
            });
            #progress = new class {
                elem = createElement("div", {
                    style: {
                        flexGrow: "1",
                        minWidth: "0",
                        margin: "0 4px",
                        fontSize: "small",
                        whiteSpace: "nowrap",

                        display: "flex",
                        flexDirection: "column",
                    },
                    hidden: true,
                });
                #text1 = createElement("span", { style: { flexGrow: "1" } });
                #text2 = createElement("span", { style: { textOverflow: "ellipsis", overflow: "hidden" } });
                #bar = createElement("progress", {
                    value: "0",
                    style: {
                        width: "100%",
                    },
                });
                current = 0;
                total = Infinity;
                #timerID = null;
                #startTime = NaN;
                #estTime = NaN;

                constructor() {
                    this.elem.append(
                        createElement("div", { class: "align-center", style: { gap: "8px" } },
                            this.#text1,
                            this.#text2,
                        ),
                        this.#bar,
                    );

                    this.update();
                }

                start() {
                    this.elem.hidden = false;

                    this.#startTime = new Date();
                    this.#timerID = setInterval(() => this.update(), 50);
                    this.update({ updateEstTime: true });
                }

                finish() {
                    clearInterval(this.#timerID);
                    
                    this.elem.hidden = true;
                    this.current = 0;
                    this.total = Infinity;
                    this.update();
                }

                update({ updateEstTime = false } = {}) {
                    const elapsedTime = new Date() - this.#startTime;
                    const ratio = this.current / this.total;
                    if (updateEstTime) this.#estTime = elapsedTime / ratio;

                    this.#text1.textContent = `${this.current}/${this.total}`;
                    this.#text2.textContent = `${this.#strTime(elapsedTime)}/${this.#strTime(this.#estTime)}`;
                    this.#bar.value = ratio;
                }

                #strTime(date) {
                    if (!isFinite(date)) return "--:--";

                    const padZero = num => (num < 10 ? "0" : "") + num;

                    const h = parseInt(date / 60 / 60 / 1000);
                    const m = padZero(parseInt(date / 60 / 1000 % 60));
                    const s = padZero(parseInt(date / 1000 % 60));

                    return h === 0 ? `${m}:${s}` : `${h}:${m}:${s}`;
                }
            }
            #mode;
            #url;
            #running = false;
            #abortController;

            constructor() {
                this.#elem.append(
                    createElement("div", { class: "align-center" },
                        createElement("div", {
                            class: "align-center",
                            style: { cursor: "pointer" },
                            onclick: e => {
                                const { left, bottom } = this.#title.getBoundingClientRect();

                                this.#modeSelector.open({ x: left, y: bottom, xmargin: -4 });
                            },
                        },
                            this.#title,
                            createElement("div", { 
                                style: { marginLeft: "4px" },
                                innerHTML: '<svg width="10" height="10" viewbox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M 1 4 l 4 4 l 4 -4"/></svg>',
                            }),
                        ),
                        this.#params.deviceButton,
                        this.#params.formulaButton,
                    ),
                    this.#params.elem,
                    createElement("div", { class: "align-center", style: { marginTop: "4px", gap: "4px" } },
                        this.#execbutton,
                        this.#spinner,
                        this.#progress.elem,
                    ),
                );
                
                this.#elem.ondragover = e => {
                    e.preventDefault();

                    e.dataTransfer.dropEffect = results.dragging.length === 1 ? "copy" : "none";
                };
                this.#elem.ondrop = e => {
                    if (results.dragging.length !== 1) return;

                    results.dragging[0].restore();
                };

                ResizeBorder.add(this.#elem, "bottom");

                addEventListener("keydown", e => {
                    if ((isMac ? e.metaKey : e.ctrlKey) && e.keyCode === 13) {
                        if (!this.#execbutton.inert) this.#execbutton.onclick();
                    }
                });

                this.#modeSelector.onchange();
            }

            get mode() {
                return this.#mode;
            }

            set mode(mode) {
                this.#mode = mode;

                this.#params.mode = mode;
                this.#modeSelector.value = mode;
            }

            get params() {
                return { mode: this.mode, ...this.#params.toObject()};
            }

            set params(object = {}) {
                this.mode = "mode" in object ? object.mode : "measure";

                this.#params.fromObject(object);
            }

            get allparams() {
                return { mode: this.mode, ...this.#params.toObject({ onlyEnabled: false })};
            }

            get running() {
                return this.#running;
            }

            set running(input) {
                this.#running = input;
                this.#spinner.hidden = !input;

                if (input) {
                    this.#execbutton.textContent = "停止";
                    this.#execbutton.onclick = () => this.#abortController.abort();
                }
                else {
                    this.#execbutton.update();
                    this.#execbutton.textContent = "実行";
                    this.#execbutton.onclick = () => this.#exec();
                    this.#progress.finish();
                }
            }

            async #exec() {
                this.running = true;
                this.#abortController = new AbortController();

                const params = this.params;
                let result, resultGroup, progressStarted;
                
                try {
                    const response = await fetch(`/${this.mode}`, {
                        method: "POST",
                        signal: this.#abortController.signal,
                        body: JSON.stringify(params),
                    });

                    for await (const line of readlines(response)) {
                        const { type, timestamp, progress, data, error } = JSON.parse(line);
                        if (error) throw error;

                        if (progress) {
                            if (!progressStarted) {
                                progressStarted = true;

                                this.#progress.start();
                            }

                            this.#progress.current = progress.current;
                            this.#progress.total = progress.total;
                            this.#progress.update({ updateEstTime: true });
                        }

                        if (type === "info" || type === "group-info") {
                            if (type === "info") {
                                if (resultGroup && result) result.running = false;

                                result = new results.Result({ timestamp, params: { ...params }, data });
                                result.running = true;

                                if (resultGroup) resultGroup.append(result);
                                else  {
                                    results.append(result);
                                    results.selected = [result];
                                }
                            }
                            
                            else if (type === "group-info") {
                                resultGroup = new results.ResultGroup({ timestamp });
                                resultGroup.running = true;

                                results.append(resultGroup);
                                results.selected = [resultGroup];
                            }
                        }

                        else {
                            if (type === "data-point") {
                                result.rawdata.V.push(data.V);
                                result.rawdata.I.push(data.I);
                                result.calc();

                                if (
                                    resultGroup && plot.targets.includes(resultGroup) && resultGroup.selected === result
                                    || plot.targets.includes(result)
                                ) plot.updateData();
                            }

                            else if (type === "data") {
                                result = new results.Result({ timestamp, params: { ...params }, data });

                                if (resultGroup) resultGroup.append(result);
                                else  {
                                    results.append(result);
                                    results.selected = [result];
                                }
                            }
                        }

                        // if (!progress) {
                        //     const result = new results.Result({ timestamp, params, data });
                            
                        //     results.append(result);
                        //     results.selected = [result];
                        // }

                        // else {
                        //     this.#progress.current = progress.current;
                        //     this.#progress.total = progress.total;

                        //     if (!result && !resultGroup) {
                        //         this.#progress.start();
                                
                        //         // 直流測定 and not (繰り返し or 温調 or 磁場変調)
                        //         if (data) {
                        //             result = new results.Result({ timestamp, params, data });
                        //             result.running = true;

                        //             results.append(result);
                        //             results.selected = [result];
                        //         }

                        //         // 繰り返し or 温調 or 磁場変調
                        //         else {
                        //             resultGroup = new results.ResultGroup({ timestamp });
                        //             resultGroup.running = true;

                        //             results.append(resultGroup);
                        //             results.selected = [resultGroup];
                        //         }
                        //     }

                        //     else {
                        //         // 直流測定 and not (繰り返し or 温調 or 磁場変調)
                        //         if (!resultGroup) {
                        //             this.#progress.update({ updateEstTime: true });
                                    
                        //             result.rawdata.V.push(data.V);
                        //             result.rawdata.I.push(data.I);
                        //             result.calc();
                        //             if (plot.targets.includes(result)) plot.updateData();
                        //         }

                        //         // 繰り返し or 温調 or 磁場変調
                        //         else {
                        //             if (Array.isArray(data.V) && Array.isArray(data.I)) {
                        //                 this.#progress.update({ updateEstTime: true });

                        //                 if (result) result.running = false;
                        //                 result = new results.Result({ timestamp, params: { ...params }, data });
                        //                 resultGroup.append(result);

                        //                 // 直流測定
                        //                 if (!data.V.length && !data.I.length) result.running = true;
                        //             }
                        //             else {
                        //                 this.#progress.update();

                        //                 result.rawdata.V.push(data.V);
                        //                 result.rawdata.I.push(data.I);
                        //                 result.calc();
                        //                 if (plot.targets.includes(resultGroup) && resultGroup.selected === result) plot.updateData();
                        //             }
                        //         }
                        //     }
                        // }
                    }
                }
                catch (error) {
                    if (error.name !== "AbortError") {
                        console.error(error);

                        if (typeof error === "string") alert([error.split("\n").slice(-2)[0], "", error].join("\n"));
                    }
                }

                this.running = false;
                if (result) result.running = false;
                if (resultGroup) resultGroup.running = false;
            }
        }();

        const results = new class {
            #list = [];
            #selected = [];
            #copied = [];
            dragging = [];
            #elem = $("#results");
            #listElem = createElement("div", {
                style: {
                    position: "relative",
                    flexGrow: "1",
                    width: "100%",
                    
                    outline: "none",
                    overflowY: "auto",
                    padding: "0",
                    scrollBehavior: "smooth",
                },
                tabIndex: "0",
                dblClickTimer: null,
                shiftStartIndex: -1,

                onclick: e => {
                    const target = this.#list.find(({ elem }) => elem.contains(e.target));
                    if (!target) return;

                    if (!e.shiftKey && !(isMac ? e.metaKey : e.ctrlKey)) {
                        this.#listElem.shiftStartIndex = this.#list.indexOf(target);
                    }

                    if (e.shiftKey) {
                        if (!this.selected.includes(this.#list[this.#listElem.shiftStartIndex])) {
                            this.#listElem.shiftStartIndex = this.#list.indexOf(this.selected.at(-1));
                        }

                        const [start, stop] = [this.#listElem.shiftStartIndex, this.#list.indexOf(target)];

                        if (start <= stop) this.selected = this.#list.slice(start, stop + 1);
                        else this.selected = this.#list.slice(stop, start + 1).reverse();
                    }
                    else if ((isMac ? e.metaKey : e.ctrlKey)) {
                        this.selected = (
                            this.selected.includes(target)
                            ? this.selected.filter(result => result !== target)
                            : [...this.selected, target]
                        );
                    }
                    else if (this.selected.length === 1 && this.selected[0] === target) {
                        if (this.#listElem.dblClickTimer === null) {
                            this.#listElem.dblClickTimer = setTimeout(() => {
                                if (this.#listElem.dblClickTimer !== null) {
                                    this.#listElem.dblClickTimer = null;

                                    target.rename();
                                }
                            }, 250);
                        }
                        else {
                            clearTimeout(this.#listElem.dblClickTimer);
                            this.#listElem.dblClickTimer = null;

                            this.#infoModal.target = target;
                            this.#infoModal.open();
                        }
                    }
                    else {
                        this.selected = [target];

                        this.#listElem.dblClickTimer = setTimeout(() => {
                            if (this.#listElem.dblClickTimer !== null) {
                                this.#listElem.dblClickTimer = null;
                            }
                        }, 250);
                    }
                },
                oncontextmenu: e => {
                    const target = this.#list.find(({ elem }) => elem.contains(e.target));
                    if (!target) return;

                    this.#contextmenu.targets = this.selected.includes(target) ? this.selected : [target];
                    this.#contextmenu.open({ x: e.x, y: e.y });
                },
                onkeydown: e => {
                    if (e.key === "ArrowUp" || e.key === "ArrowDown") {
                        e.preventDefault();

                        const lastTargetIndex = [
                            this.#list.indexOf(this.selected.slice(-1)[0]),
                            this.#list.findIndex(({ elem }) => elem === e.target),
                        ].find(i => i !== -1) ?? -1;

                        if (e.shiftKey) {
                            if (this.#listElem.shiftStartIndex === -1) this.#listElem.shiftStartIndex = lastTargetIndex;
                        }
                        else {
                            this.#listElem.shiftStartIndex = -1;
                        }

                        const targetIndex = (
                            lastTargetIndex === -1
                            ? (e.key === "ArrowUp" ? this.#list.length - 1 : 0)
                            : Math.max(0, Math.min(lastTargetIndex + (e.key === "ArrowUp" ? -1 : 1), this.#list.length - 1))
                        );

                        if (e.shiftKey && this.#listElem.shiftStartIndex !== -1) {
                            const [start, stop] = [this.#listElem.shiftStartIndex, targetIndex];

                            if (start <= stop) this.selected = this.#list.slice(start, stop + 1);
                            else this.selected = this.#list.slice(stop, start + 1).reverse();
                        }
                        else {
                            this.selected = [this.#list[targetIndex]];
                        }
                        
                        this.#list[targetIndex].elem.focus();
                    }

                    if (e.key === "Delete") {
                        if (!this.selected.length) return;

                        this.remove(...this.selected);
                    }

                    if ((isMac ? e.metaKey : e.ctrlKey)) {
                        if (e.key === "a") {
                            e.preventDefault();

                            this.selected = this.#list;
                        }

                        if (e.key === "c" || e.key === "x") {
                            this.#copied = this.selected;

                            if (e.key === "x") this.#remove(...this.selected);
                        }

                        if (e.key === "d" || e.key === "v") {
                            const entries = [];

                            for (const srcResult of e.key === "d" ? this.selected : this.#copied) {
                                const result = new srcResult.constructor(structuredClone(srcResult.toObject()));
                                result.saved = srcResult.saved;

                                entries.push(result);
                            }

                            if (entries.length) {
                                const activeIndex = this.#list.indexOf(this.selected.at(-1));
                                const targetIndex = this.#list.findIndex(({ group }, index) => index > activeIndex && !group);

                                this.#insert(targetIndex, ...entries);
                                this.selected = entries;
                            }
                        }
                    }
                },

                dragTargetIndex: -1,
                ondragstart: e => {
                    const target = this.#list.find(({ elem }) => elem.contains(e.target));
                    if (!target) return;

                    this.dragging = this.selected.includes(target) ? this.selected : [target];
                    this.#dragLine.update();
                    this.#dragImage.update();
                    e.dataTransfer.setDragImage(this.#dragImage, -8, 0);
                },
                ondragover: e => {
                    if (!this.dragging.length) return;
                    e.preventDefault();

                    this.#dragLine.hidden = false;
                    e.dataTransfer.dropEffect = "move";

                    let nearestIndex, nearestPosition;
                    [...this.#list, this.#list.at(-1)].forEach((result, index) => {
                        if (result.group) return;

                        const { top, bottom } = result.elem.getBoundingClientRect();
                        const position = index < this.#list.length ? top : bottom;
                        if (nearestIndex === undefined || Math.abs(position - e.y) < Math.abs(nearestPosition - e.y)) {
                            nearestIndex = index;
                            nearestPosition = position;
                        }
                    });

                    if (!this.dragging.includes(this.#list[nearestIndex - 1])
                        || !this.dragging.includes(this.#list[nearestIndex])) {
                        this.#listElem.dragTargetIndex = nearestIndex;
                        this.#dragLine.style.top = `${nearestPosition}px`;
                    }
                },
                ondragenter: e => {
                    this.#listElem.ondragover(e);
                },
                ondragleave: e => {
                    if (!this.dragging.length) return;
                    if (this.#listElem.contains(e.relatedTarget)) return;
                    e.preventDefault();

                    this.#dragLine.hidden = true;
                },
                ondragend: () => {
                    this.dragging = [];
                    this.#dragLine.hidden = true;
                },
                ondrop: e => {
                    if (!this.dragging.length) return;
                    if (this.#listElem.dragTargetIndex === -1) return;
                    
                    const focused = document.activeElement;
                    this.#insert(this.#listElem.dragTargetIndex, ...this.dragging);
                    focused.focus();

                    for (const result of this.dragging) {
                        if (result instanceof this.ResultGroup) {
                            if (result.expanded) result.expanded = true;
                        }
                    }

                    this.#listElem.dragTargetIndex = -1;
                },
            });
            #spinner = createElement("div", {
                class: "spinner",
                hidden: true,
            });
            #dragLine = createElement("div", {
                style: {
                    position: "absolute",
                    zIndex: "1",

                    border: "1px solid var(--text)",
                    pointerEvents: "none",
                },
                hidden: true,
                update: () => {
                    const { left, width } = this.#listElem.getBoundingClientRect();

                    results.#dragLine.style.left = `${left}px`;
                    results.#dragLine.style.width = `${width}px`;
                },
            });
            #dragImage = createElement("div", {
                style: {
                    position: "absolute",

                    backgroundColor: "var(--background)",
                    border: "1px solid var(--border)",
                    borderRadius: "4px",
                    fontSize: "0.9em",
                    fontWeight: "bold",
                    padding: "2px 4px",
                    transform: "translateX(200vw)",
                    whiteSpace: "nowrap",
                },
                update: () => {
                    this.#dragImage.textContent = (
                        this.dragging.length === 1 ? this.dragging[0].displayName
                        : `${this.dragging.length}個の項目`
                    );
                },
            });
            #namelist = createElement("datalist", {
                id: "namelist",
                update: () => {
                    while (this.#namelist.firstChild) this.#namelist.firstChild.remove();
                    this.#namelist.append(...this.#list.map(({ name }) => name ? createElement("option", null, name) : ""));
                },
            });
            #contextmenu = new class {
                #targets;
                #menu = new Contextmenu();
                #edit = createElement("button", {
                    onclick: () => {
                        this.#menu.close();

                        if (this.targets.length === 1) {
                            this.targets[0].edit();
                        }
                        else {
                            const { left, top, bottom } = this.targets.reduce((obj, { elem }) => {
                                const { left, top, bottom } = elem.getBoundingClientRect();

                                return {
                                    left: obj.left === undefined || left < obj.left ? left : obj.left,
                                    top: obj.top === undefined || top < obj.top ? top : obj.top,
                                    bottom: obj.bottom === undefined || bottom > obj.bottom ? bottom : obj.bottom,
                                };
                            }, {});

                            results.#editor.targets = this.targets;
                            results.#editor.open({ x: left, y: (top + bottom) / 2, xanchor: "right", xmargin: 4, ymargin: (top - bottom) / 2 });
                        }
                    },
                },
                    createElement("div", {
                        class: "icon",
                        innerHTML: '<svg width="14" height="14" viewbox="0 0 10 10" fill="none" stroke="currentColor"><path d="M 1 9 v -1.5 l 6 -6 l 1.5 1.5 l -6 6 z M 6 3 l 1.5 1.5"/></svg>',
                    }),
                    "編集",
                );
                #fit = createElement("button", {
                    onclick: () => {
                        this.targets[0].fit();
                        this.#menu.close();
                    },
                },
                    createElement("div", {
                        class: "icon",
                        innerHTML: '<svg width="14" height="14" viewBox="0 0 100 100" fill="currentColor" stroke="none"><path d="M 10 65 l 80 -40 v 10 l -80 40 z M 20 40 m 0 -10 a 10 10 0 1 1 -0.01 0 M 70 15 m 0 -10 a 10 10 0 1 1 -0.01 0 M 55 75 m 0 -10 a 10 10 0 1 1 -0.01 0"/></svg>',
                    }),
                    "フィット",
                );
                #grouping = createElement("button", {
                    onclick: () => {
                        this.#menu.close();

                        const resultGroup = new results.ResultGroup({ timestamp: round(new Date() / 1000) });

                        results.#insertBefore(this.targets.at(-1), resultGroup);
                        results.#remove(...this.targets);
                        resultGroup.append(...this.targets.map(result => (
                            result instanceof results.ResultGroup ? result.list : result
                        )).flat());
                        resultGroup.saved = this.targets.every(({ saved }) => saved);

                        results.selected = [resultGroup];
                    },
                },
                    createElement("div", {
                        class: "icon",
                    }),
                    "グループ化",
                );
                #ungrouping = createElement("button", {
                    onclick: () => {
                        this.#menu.close();

                        const target = this.targets[0];

                        target.list.forEach(result => {
                            result.group = null;
                        });
                        results.#insert(
                            results.#list.indexOf(target),
                            ...target.list,
                        );
                        results.#remove(target);
                        results.selected = target.list;
                    },
                },
                    createElement("div", {
                        class: "icon",
                    }),
                    "グループ化解除",
                );
                #restore = createElement("button", {
                    onclick: () => {
                        this.#menu.close();
                        this.targets[0].restore();
                    },
                },
                    createElement("div", {
                        class: "icon",
                        innerHTML: '<svg width="14" height="14" viewbox="0 0 10 10" fill="none" stroke="currentColor"><path d="M 2 4 l 3 -3 l 3 3 m -3 -3 v 4 m 0 1 v 1 m 0 1 v 1"/></svg>',
                    }),
                    "設定の復元",
                );
                #rename = createElement("button", {
                    onclick: () => {
                        this.#menu.close();
                        this.targets[0].rename();
                    },
                },
                    createElement("div", {
                        class: "icon",
                        innerHTML: '<svg width="14" height="14" viewbox="0 0 10 10" fill="none" stroke="currentColor"><rect x="1" y="2" width="8" height="6" rx="1"></rect><path d="M 6 0 h 2 h -1 v 10 h -1 h 2"></path><text x="3" y="6.4" font-size="4" stroke-width="0.4">A</text></svg>',
                    }),
                    "名前の変更",
                );
                #delete = createElement("button", {
                    onclick: () => {
                        this.#menu.close();
                        
                        results.remove(...this.targets);
                    },
                },
                    createElement("div", {
                        class: "icon",
                        innerHTML: '<svg width="14" height="14" viewbox="0 0 10 10"><path fill="none" stroke="currentColor" d="M 1 1 L 9 9 M 1 9 L 9 1"></path></svg>',
                    }),
                    "削除",
                );
                
                constructor() {
                    this.#menu.elem.append(
                        this.#edit,
                        this.#fit,
                        this.#grouping,
                        this.#ungrouping,
                        this.#restore,
                        this.#rename,
                        this.#delete,
                    );
                }

                get targets() {
                    return this.#targets;
                }

                set targets(targets) {
                    this.#targets = targets;

                    this.#fit.hidden = !(targets.length === 1);
                    this.#grouping.hidden = !(targets.some(target => target instanceof results.Result));
                    this.#ungrouping.hidden = !(targets.length === 1 && targets[0] instanceof results.ResultGroup);
                    this.#rename.hidden = !(targets.length === 1);
                    this.#restore.hidden = !(targets.length === 1);
                }

                open(pos) {
                    this.#menu.open(pos);
                }
            }();
            #sorter = new class {
                #menu = new Selectmenu({
                    values: ["名前 (昇順)", "名前 (降順)", "日時 (昇順)", "日時 (降順)"],
                    autoclose: false,
                    onchange: () => this.#onchange(),
                });
                button = createElement("button", {
                    class: "icon",
                    title: "並べ替え",
                    innerHTML: '<svg width="16" height="16" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M 1 2.5 h 4 M 1 5 h 3 M 1 7.5 h 2 M 7 2 v 6 m -1.5 -1.5 l 1.5 1.5 l 1.5 -1.5"/></svg>',
                    onclick: () => {
                        this.open();
                    },
                });

                open() {
                    const value = this.#menu.value;

                    if (results.#list.length && (
                        (
                            value === "名前 (昇順)"
                            && !results.#list.reduce((pre, cur) => pre && pre.displayName <= cur.displayName && cur)
                        ) || (
                            value === "名前 (降順)"
                            && !results.#list.reduce((pre, cur) => pre && pre.displayName >= cur.displayName && cur)
                        ) || (
                            value === "日時 (昇順)"
                            && !results.#list.reduce((pre, cur) => pre && pre.date <= cur.date && cur)
                        ) || (
                            value === "日時 (降順)"
                            && !results.#list.reduce((pre, cur) => pre && pre.date >= cur.date && cur)
                        )
                    )) this.#menu.value = undefined;

                    const { top, right, height } = this.button.getBoundingClientRect();
                    this.#menu.open({ x: right, y: top + height / 2, xanchor: "right", yanchor: "bottom", ymargin: height / 2 + 4 });
                }

                #onchange() {
                    const value = this.#menu.value;

                    if (value === "名前 (昇順)") {
                        results.#list.sort((a, b) => {
                            if (a.displayName < b.displayName) return -1;
                            if (a.displayName === b.displayName) return 0;
                            if (a.displayName > b.displayName) return 1;
                        });
                    }
                    else if (value === "名前 (降順)") {
                        results.#list.sort((a, b) => {
                            if (a.displayName < b.displayName) return 1;
                            if (a.displayName === b.displayName) return 0;
                            if (a.displayName > b.displayName) return -1;
                        });
                    }
                    else if (value === "日時 (昇順)") {
                        results.#list.sort((a, b) => {
                            if (a.date < b.date) return -1;
                            if (a.date === b.date) return 0;
                            if (a.date > b.date) return 1;
                        });
                    }
                    else if (value === "日時 (降順)") {
                        results.#list.sort((a, b) => {
                            if (a.date < b.date) return 1;
                            if (a.date === b.date) return 0;
                            if (a.date > b.date) return -1;
                        });
                    }

                    results.#listElem.append(...results.#list.map(({ elem }) => elem));
                }
            }();
            #editor = new class {
                #targets;
                #menu = new Popup({ style: { width: "250px", maxHeight: "300px", display: "flex", flexDirection: "column" } });
                #targetname = createElement("h4", {
                    style: {
                        flexShrink: "0",

                        color: "var(--text-secondary)",
                        overflow: "hidden",
                        padding: "8px 8px 0",
                        textOverflow: "ellipsis",
                        whiteSpace: "nowrap",
                    },
                });
                #data = new class {
                    #targets;
                    list = [
                        new NamedForm({
                            name: "A",
                            lname: "$A$",
                            type: "number",
                            required: false,
                            units: {
                                "mm²": 1e-6,
                                "μm²": 1e-12,
                                "nm²": 1e-18,
                            },
                            defaultUnit: "μm²",
                            onchange: () => this.#onchange()
                        }),
                        new NamedForm({
                            name: "d",
                            lname: "$d$",
                            type: "number",
                            required: false,
                            units: {
                                "μm": 1e-6,
                                "nm": 1e-9,
                                "pm": 1e-12,
                            },
                            defaultUnit: "nm",
                            onchange: () => this.#onchange()
                        }),
                    ];

                    get targets() {
                        return this.#targets;
                    }

                    set targets(targets) {
                        this.#targets = targets;
                        
                        for (const form of this.list) {
                            const values = targets.map(({ rawdata }) => rawdata[form.name]).flat();

                            form.value = values.every(v => v === values[0]) ? values[0] : undefined;
                        }
                    }

                    #onchange() {
                        if (this.list.some(({ isValid }) => !isValid)) return;

                        for (const target of this.targets) {
                            for (const { name, value } of this.list) {
                                target.rawdata[name] = value;
                            }
                            target.saved = false;
                        }

                        if (this.targets.some(target => plot.targets.includes(target))) plot.updateData();
                    }
                }();
                #params = new class {
                    #targets;
                    list = [
                        new NamedForm({
                            name: "channel_I",
                            lname: "Ch $I$",
                            type: "select",
                            values: [
                                "Ch1",
                                "Ch2",
                                "Ch3",
                                "Ch4",
                                "Ch1-Ch2",
                                "Ch1-Ch3",
                                "Ch1-Ch4",
                                "Ch2-Ch1",
                                "Ch2-Ch3",
                                "Ch2-Ch4",
                                "Ch3-Ch1",
                                "Ch3-Ch2",
                                "Ch3-Ch4",
                                "Ch4-Ch1",
                                "Ch4-Ch2",
                                "Ch4-Ch3",
                            ],
                            required: false,
                            onchange: () => this.#onchange(),
                        }),
                        new NamedForm({
                            name: "channel_V",
                            lname: "Ch $V$",
                            type: "select",
                            values: [
                                "Ch1",
                                "Ch2",
                                "Ch3",
                                "Ch4",
                                "Ch1-Ch2",
                                "Ch1-Ch3",
                                "Ch1-Ch4",
                                "Ch2-Ch1",
                                "Ch2-Ch3",
                                "Ch2-Ch4",
                                "Ch3-Ch1",
                                "Ch3-Ch2",
                                "Ch3-Ch4",
                                "Ch4-Ch1",
                                "Ch4-Ch2",
                                "Ch4-Ch3",
                            ],
                            required: false,
                            onchange: () => this.#onchange(),
                        }),
                        new NamedForm({
                            name: "Gain_I",
                            lname: "Gain $I$",
                            type: "select",
                            values: [
                                1, 2, 5,
                            ],
                            units: {
                                "x1": 1,
                                "x10": 10,
                                "x10²": 100,
                                "x10³": 1000,
                            },
                            required: false,
                            onchange: () => this.#onchange(),
                        }),
                        new NamedForm({
                            name: "Gain_V",
                            lname: "Gain $V$",
                            type: "select",
                            values: [
                                1, 2, 5,
                            ],
                            units: {
                                "x1": 1,
                                "x10": 10,
                                "x10²": 100,
                                "x10³": 1000,
                            },
                            required: false,
                            onchange: () => this.#onchange(),
                        }),
                        new NamedForm({
                            name: "R_I",
                            lname: "$R_{I}$",
                            type: "number",
                            units: {
                                "kΩ": 1e3,
                                "Ω": 1,
                            },
                            required: false,
                            onchange: () => this.#onchange(),
                        }),
                        
                        // new NamedForm({
                        //     name: "Gain_I",
                        //     lname: "$G_{I}$",
                        //     type: "select",
                        //     values: [
                        //         1, 2, 5,
                        //     ],
                        //     units: {
                        //         "x1": 1,
                        //         "x10": 10,
                        //         "x10²": 100,
                        //         "x10³": 1000,
                        //     },
                        //     required: false,
                        //     onchange: () => this.#onchange(),
                        // }),
                        // new NamedForm({
                        //     name: "Gain_V",
                        //     lname: "$G_{V}$",
                        //     type: "select",
                        //     values: [
                        //         1, 2, 5,
                        //     ],
                        //     units: {
                        //         "x1": 1,
                        //         "x10": 10,
                        //         "x10²": 100,
                        //         "x10³": 1000,
                        //     },
                        //     required: false,
                        //     onchange: () => this.#onchange(),
                        // }),
                        // new NamedForm({
                        //     name: "R_I",
                        //     lname: "$R_{I}$",
                        //     type: "number",
                        //     units: {
                        //         "kΩ": 1e3,
                        //         "Ω": 1,
                        //     },
                        //     required: false,
                        //     onchange: () => this.#onchange(),
                        // }),
                    ];

                    get targets() {
                        return this.#targets;
                    }

                    set targets(targets) {
                        this.#targets = targets;
                        
                        for (const form of this.list) {
                            const values = [...new Set(targets.map(({ params }) => params[form.name]).flat())];

                            form.value = values.length === 1 ? values[0] : undefined;

                            form.disabled = !targets.some(target => form.name in target.params);
                            form.form.disabled = (
                                form.name === "channel_I" && targets.every(target => "I" in target.rawdata)
                                || form.name === "channel_V" && targets.every(target => "V" in target.rawdata)
                            );
                        }
                    }

                    #onchange() {
                        if (this.list.some(({ isValid }) => !isValid)) return;

                        for (const target of this.targets) {
                            for (const { name, value } of this.list) {
                                if (value !== undefined) target.params[name] = value;
                            }
                            target.saved = false;
                        }

                        this.targets.forEach(target => target.calc());
                        if (this.targets.some(target => plot.targets.includes(target))) plot.updateData();
                    }
                }();
                #calcparams = new class {
                    #targets;
                    list = Object.entries(info.calcparams).map(([key, { name, lname, unit, defaultValue }]) => {
                        const args = {
                            name,
                            lname: `$${lname}$`,
                            type: "number",
                            required: false,
                            units: {
                                [`${unit}`]: 1,
                                [`m${unit}`]: 1e-3,
                                [`μ${unit}`]: 1e-6,
                                [`n${unit}`]: 1e-9,
                            },
                            defaultValue,
                            onchange: () => this.#onchange(),
                        };
                        if (key === "N_SMA") Object.assign(args, { step: 1, min: 1, units: undefined });

                        return new NamedForm(args);
                    });
                    get targets() {
                        return this.#targets;
                    }

                    set targets(targets) {
                        this.#targets = targets;
                        
                        for (const form of this.list) {
                            const values = targets.map(({ calcparams }) => calcparams[form.name]).flat();

                            form.value = values.every(v => v === values[0]) ? values[0] : undefined;
                        }
                    }

                    #onchange() {
                        if (this.list.some(({ isValid }) => !isValid)) return;

                        for (const target of this.targets) {
                            for (const { name, value } of this.list) {
                                if (value !== undefined) target.calcparams[name] = value;
                            }
                            target.saved = false;
                        }
                        for (const { name, value } of this.list) {
                            if (value !== undefined) info.calcparams[name].defaultValue = value;
                        }

                        this.targets.forEach(target => target.calc());
                        if (this.targets.some(target => plot.targets.includes(target))) plot.updateData();
                    }
                }();
                
                constructor() {
                    this.#menu.elem.append(
                        this.#targetname,

                        createElement("div", { style: { flexGrow: "1", overflowY: "auto", padding: "4px 8px" } },
                            ...this.#data.list.map(({ elem }) => elem),
                            createElement("div", { class: "hline" }),
                            ...this.#params.list.map(({ elem }) => elem),
                            createElement("div", { class: "hline" }),
                            ...this.#calcparams.list.map(({ elem }) => elem),
                        ),
                    );
                }

                get targets() {
                    return this.#targets;
                }

                set targets(targets) {
                    this.#targets = targets;
                    if (targets.length === 1) {
                        this.#targetname.textContent = targets[0].displayName;
                        this.#targetname.title = targets[0].displayName;
                    }
                    else {
                        this.#targetname.textContent = `${targets.length}個の項目`;
                        this.#targetname.title = targets.map(target => target.displayName).join("\n");
                    }

                    this.#data.targets = targets;
                    this.#params.targets = targets;
                    this.#calcparams.targets = targets;
                }

                open(pos) {
                    this.#menu.open(pos);
                }
            }();
            #fitter = new class {
                #menu = new Popup({ style: { width: "250px", maxHeight: "400px", display: "flex", flexDirection: "column" } });
                #title = createElement("h2");
                #modeSelector = new Selectmenu({
                    titleElem: this.#title,
                    values: {
                        "I-Vフィット": "I-V",
                        "Ic-Aフィット": "Ic-A",
                        "Ic(th)-Aフィット": "Ic_th-A",
                        "RnA-Aフィット": "RnA-A",
                        "RnA-dフィット": "RnA-d",
                        "I-Φフィット": "Ic12-Ibias",
                    },
                    defaultValue: "I-V",
                    props: { style: { fontSize: "1em" } },
                    onchange: () => {
                        this.mode = this.#modeSelector.value;
                    },
                    update: () => {
                        const { values, options } = this.#modeSelector;

                        for (const i in options) {
                            if (Object.values(values)[i] === "I-V") {
                                options[i].inert = !(this.target instanceof results.Result);
                            }
                            else {
                                options[i].inert = !(this.target instanceof results.ResultGroup);
                            }
                        }
                    },
                });
                #formulaButton = createElement("button", {
                    style: { fontSize: "0.75em", flexShrink: "0", marginLeft: "auto" },
                    onclick: () => {
                        this.#menu.fixed = true;
                        this.#params.formulaModal.onclose = () => {
                            setTimeout(() => {
                                this.#menu.elem.focus();
                                this.#menu.fixed = false;
                            }, 0);
                        };

                        this.#params.formulaModal.open();
                    },
                }, "数式");
                #targetname = createElement("h4", {
                    style: {
                        color: "var(--text-secondary)",
                        overflow: "hidden",
                        textOverflow: "ellipsis",
                        whiteSpace: "nowrap",
                    },
                });
                #params = new class {
                    elem = createElement("div");
                    #outerThis;
                    #mode;
                    #modes = {
                        "I-V": {
                            formulaModal: new Modal({ style: { padding: "12px 16px" } },
                                createElement("h3", null, "RSJ"),
                                createElement("div", {
                                    style: { width: "min-content", padding: "0 16px" },
                                    innerHTML: String.raw`$$ I=I_{\rm c} \sin \theta + \frac{\dot \theta}{R_{\rm N}} + C \ddot \theta $$`,
                                }),
                                createElement("h3", null, "RSJN"),
                                createElement("div", {
                                    style: { width: "min-content", padding: "0 16px" },
                                    innerHTML: String.raw`$$ I=I_{\rm c} \sin \theta + \frac{\dot \theta}{R_{\rm N}} \frac{( \dot \theta / V_{\rm g} ) ^ n}{1 + ( \dot \theta / V_{\rm g} ) ^ n} + C \ddot \theta $$`,
                                }),
                                createElement("h3", null, "TJM"),
                                createElement("a", {
                                    href: "https://doi.org/10.1103/PhysRev.147.255",
                                    referrerpolicy: "no-referrer",
                                    target: "_blank",
                                }, "N. R. Werthamer, Phys. Rev. 147(1), 255, 1966."),

                                createElement("h5", { style: { marginTop: "20px" } }, "※参考"),
                                createElement("a", {
                                    href: "http://pscan2sim.org/Windows/PSCAN2_UserGuide_ak.pdf",
                                    referrerpolicy: "no-referrer",
                                    target: "_blank",
                                }, "http://pscan2sim.org/Windows/PSCAN2_UserGuide_ak.pdf")
                            ),
                            options: {
                                model: new NamedForm({
                                    name: "model",
                                    lname: "モデル",
                                    type: "select",
                                    values: [
                                        "RSJ",
                                        "RSJN",
                                        "TJM",
                                    ],
                                    defaultValue: "TJM",
                                }),
                                T: new NamedForm({
                                    name: "T",
                                    lname: "$T$",
                                    type: "number",
                                    units: {
                                        "K": 1,
                                        "mK": 1e-3,
                                    },
                                }),
                                Ic: new NamedForm({
                                    name: "Ic",
                                    lname: "$I_{\\rm c}$",
                                    type: "number",
                                    units: {
                                        "mA": 1e-3,
                                        "μA": 1e-6,
                                        "nA": 1e-9,
                                    },
                                    defaultUnit: "μA",
                                }),
                                IcRn: new NamedForm({
                                    name: "IcRn",
                                    lname: "$I_{\\rm c} R_{\\rm N}$",
                                    type: "number",
                                    units: {
                                        "mV": 1e-3,
                                        "μV": 1e-6,
                                        "nV": 1e-9,
                                    },
                                    defaultUnit: "mV",
                                }),
                                n: new NamedForm({
                                    name: "n",
                                    lname: "$n$",
                                    type: "number",
                                    step: 2,
                                    min: 0,
                                    defaultValue: 10,
                                }),
                                asymmetric: new NamedForm({
                                    name: "asymmetric",
                                    lname: "非対称なギャップ",
                                    type: "checkbox",
                                    defaultValue: false,
                                }),
                                V_start: new NamedForm({
                                    name: "V_start",
                                    lname: "$V_{\\rm start}$",
                                    type: "number",
                                    units: {
                                        "mV": 1e-3,
                                        "μV": 1e-6,
                                        "nV": 1e-9,
                                    },
                                    defaultUnit: "mV",
                                    required: false,
                                    props: { style: { marginTop: "0.25em", paddingTop: "0.25em", borderTop: "1px solid var(--border)" } },
                                }),
                                V_stop: new NamedForm({
                                    name: "V_stop",
                                    lname: "$V_{\\rm stop}$",
                                    type: "number",
                                    units: {
                                        "mV": 1e-3,
                                        "μV": 1e-6,
                                        "nV": 1e-9,
                                    },
                                    defaultUnit: "mV",
                                    required: false,
                                }),
                                epsilon: new NamedForm({
                                    name: "epsilon",
                                    lname: "許容誤差",
                                    type: "number",
                                    defaultValue: 1e-6,
                                    nameprops: { style: { fontSize: "0.9em" } },
                                }),
                                t_wait: new NamedForm({
                                    name: "t_wait",
                                    lname: "$t_{\\rm wait}$",
                                    type: "number",
                                    units: {
                                        "ms": 1e-3,
                                        "μs": 1e-6,
                                        "ns": 1e-9,
                                        "ps": 1e-12,
                                        "fs": 1e-15,
                                    },
                                    defaultValue: 10e-12,
                                    defaultUnit: "ps",
                                }),
                                t_min: new NamedForm({
                                    name: "t_min",
                                    lname: "$t_{\\rm min}$",
                                    type: "number",
                                    units: {
                                        "ms": 1e-3,
                                        "μs": 1e-6,
                                        "ns": 1e-9,
                                        "ps": 1e-12,
                                        "fs": 1e-15,
                                    },
                                    defaultValue: 0,
                                    defaultUnit: "ps",
                                }),
                                t_max: new NamedForm({
                                    name: "t_max",
                                    lname: "$t_{\\rm max}$",
                                    type: "number",
                                    units: {
                                        "ms": 1e-3,
                                        "μs": 1e-6,
                                        "ns": 1e-9,
                                        "ps": 1e-12,
                                        "fs": 1e-15,
                                    },
                                    defaultValue: 100e-12,
                                    defaultUnit: "ps",
                                }),
                            },
                            initparams: {
                                delta_sm: new NamedForm({
                                    name: "delta_sm",
                                    lname: "$\\delta_{\\rm sm}$",
                                    description: "Smearing of the Riedel peaks",
                                    type: "number",
                                    defaultValue: 0.015,
                                }),
                                Vg: new NamedForm({
                                    name: "Vg",
                                    lname: "$V_{\\rm g}$",
                                    type: "number",
                                    units: {
                                        "mV": 1e-3,
                                        "μV": 1e-6,
                                        "nV": 1e-9,
                                    },
                                    defaultUnit: "mV",
                                }),
                                Vg_plus: new NamedForm({
                                    name: "Vg_plus",
                                    lname: "$V_{\\rm g}^{+}$",
                                    type: "number",
                                    units: {
                                        "mV": 1e-3,
                                        "μV": 1e-6,
                                        "nV": 1e-9,
                                    },
                                    defaultUnit: "mV",
                                }),
                                Vg_minus: new NamedForm({
                                    name: "Vg_minus",
                                    lname: "$V_{\\rm g}^{-}$",
                                    type: "number",
                                    units: {
                                        "mV": 1e-3,
                                        "μV": 1e-6,
                                        "nV": 1e-9,
                                    },
                                    defaultValue: 0,
                                    defaultUnit: "mV",
                                }),
                                Q: new NamedForm({
                                    name: "Q",
                                    lname: "$Q$",
                                    type: "number",
                                }),
                                beta_c: new NamedForm({
                                    name: "beta_c",
                                    lname: "$\\beta_{\\rm c}$",
                                    type: "number",
                                    defaultValue: 100,
                                }),
                            },
                            update: () => {
                                const setHidden = (form, value) => {
                                    form.disabled = value;
                                    form.elem.hidden = value;
                                };
                                const { model, T, Ic, IcRn, n, asymmetric } = this.options;
                                const { delta_sm, Vg, Vg_plus, Vg_minus, Q } = this.initparams;

                                setHidden(T, model.value !== "TJM");
                                setHidden(asymmetric, model.value !== "TJM");
                                setHidden(delta_sm, model.value !== "TJM");
                                setHidden(Vg, !(model.value === "RSJN" || model.value === "TJM" && !asymmetric.value));
                                setHidden(Vg_plus, !(model.value === "TJM" && asymmetric.value));
                                setHidden(Vg_minus, !(model.value === "TJM" && asymmetric.value));
                                setHidden(n, model.value !== "RSJN");
                                setHidden(Q, model.value !== "TJM");
                            },
                            onchangeTarget: () => {
                                const { T, Ic, IcRn } = this.options;

                                T.value = this.#outerThis.target.data.T;
                                Ic.value = this.#outerThis.target.data.Ic;
                                IcRn.value = this.#outerThis.target.data.IcRn;
                            },
                        },
                        "Ic-A": {
                            formulaModal: new Modal({ style: { padding: "12px 16px 0" } },
                                createElement("h3", null, "正方形"),
                                createElement("div", {
                                    style: { width: "min-content" },
                                    innerHTML: String.raw`$$I_{\rm c}=\int_0^{a} \!\! \int_0^{a} J_{\rm c} \exp \left( -d(x,y) / \lambda_{\rm J} \right) dxdy \\a=\sqrt A-2\Delta a$$`,
                                }),
                                createElement("h3", null, "円形"),
                                createElement("div", {
                                    style: { width: "min-content" },
                                    innerHTML: String.raw`$$I_{\rm c}=\int_0^{2\pi} \!\!\!\! \int_0^{r} J_{\rm c} \exp \left( -(r - r') / \lambda_{\rm J} \right) r'dr'd\theta \\r=\sqrt{\frac{A}{\pi}} -\Delta a$$`,
                                }),
                            ),
                            options: {
                                shape: new NamedForm({
                                    name: "shape",
                                    lname: "形状",
                                    type: "select",
                                    values: {
                                        "正方形": "square",
                                        "円形": "circle",
                                    },
                                    defaultValue: "square",
                                }),
                                include_delta_a: new NamedForm({
                                    name: "include_delta_a",
                                    lname: "シュリンク$\\Delta a$を考慮",
                                    type: "checkbox",
                                    defaultValue: true,
                                    props: { style: { margin: "0.25em 0" } },
                                }),
                                include_lambda_J: new NamedForm({
                                    name: "include_lambda_J",
                                    lname: "ジョセフソン侵入長$\\lambda_{\\rm J}$を考慮",
                                    type: "checkbox",
                                    defaultValue: true,
                                    props: { style: { margin: "0.25em 0" } },
                                }),
                            },
                            initparams: {
                                Jc: new NamedForm({
                                    name: "Jc",
                                    lname: "${\\it J}_{\\rm c}$",
                                    type: "number",
                                    units: {
                                        "kA/cm²": 1e3,
                                        "A/cm²": 1,
                                        "mA/cm²": 1e-3,
                                    },
                                    defaultUnit: "A/cm²",
                                    required: false,
                                }),
                                delta_a: new NamedForm({
                                    name: "delta_a",
                                    lname: "$\\Delta a$",
                                    type: "number",
                                    units: {
                                        "mm": 1e-3,
                                        "μm": 1e-6,
                                        "nm": 1e-9,
                                    },
                                    defaultUnit: "nm",
                                    required: false,
                                }),
                                lambda_J: new NamedForm({
                                    name: "lambda_J",
                                    lname: "$\\lambda_{\\rm J}$",
                                    type: "number",
                                    units: {
                                        "mm": 1e-3,
                                        "μm": 1e-6,
                                        "nm": 1e-9,
                                    },
                                    defaultUnit: "nm",
                                    required: false,
                                }),
                            },
                            update: () => {
                                const { include_delta_a, include_lambda_J } = this.options;
                                const { delta_a, lambda_J } = this.initparams;

                                delta_a.disabled = !include_delta_a.value;
                                lambda_J.disabled = !include_lambda_J.value;
                            },
                        },
                        "Ic_th-A": {
                            formulaModal: new Modal({
                                style: { width: "min-content", padding: "0 16px" },
                                innerHTML: String.raw`$$I_{\rm c}^{\rm th}=\int_0^{a} \!\! \int_0^{a} J_{\rm c}^{\rm th} \exp \left( -d(x,y) / \lambda_{\rm J} \right) dxdy \\a=\sqrt A-2\Delta a$$`,
                            }),
                            options: {
                                shape: new NamedForm({
                                    name: "shape",
                                    lname: "形状",
                                    type: "select",
                                    values: {
                                        "正方形": "square",
                                        "円形": "circle",
                                    },
                                    defaultValue: "square",
                                }),
                                include_delta_a: new NamedForm({
                                    name: "include_delta_a",
                                    lname: "シュリンク$\\Delta a$を考慮",
                                    type: "checkbox",
                                    defaultValue: true,
                                    props: { style: { margin: "0.25em 0" } },
                                }),
                                include_lambda_J: new NamedForm({
                                    name: "include_lambda_J",
                                    lname: "ジョセフソン侵入長$\\lambda_{\\rm J}$を考慮",
                                    type: "checkbox",
                                    defaultValue: true,
                                    props: { style: { margin: "0.25em 0" } },
                                }),
                            },
                            initparams: {
                                Jc: new NamedForm({
                                    name: "Jc",
                                    lname: "${\\it J}_{\\rm c}$",
                                    type: "number",
                                    units: {
                                        "kA/cm²": 1e3,
                                        "A/cm²": 1,
                                        "mA/cm²": 1e-3,
                                    },
                                    defaultUnit: "A/cm²",
                                    required: false,
                                }),
                                delta_a: new NamedForm({
                                    name: "delta_a",
                                    lname: "$\\Delta a$",
                                    type: "number",
                                    units: {
                                        "mm": 1e-3,
                                        "μm": 1e-6,
                                        "nm": 1e-9,
                                    },
                                    defaultUnit: "nm",
                                    required: false,
                                }),
                                lambda_J: new NamedForm({
                                    name: "lambda_J",
                                    lname: "$\\lambda_{\\rm J}$",
                                    type: "number",
                                    units: {
                                        "mm": 1e-3,
                                        "μm": 1e-6,
                                        "nm": 1e-9,
                                    },
                                    defaultUnit: "nm",
                                    required: false,
                                }),
                            },
                            update: () => {
                                const { include_delta_a, include_lambda_J } = this.options;
                                const { delta_a, lambda_J } = this.initparams;

                                delta_a.disabled = !include_delta_a.value;
                                lambda_J.disabled = !include_lambda_J.value;
                            },
                        },
                        "RnA-A": {
                            options: {
                                shape: new NamedForm({
                                    name: "shape",
                                    lname: "形状",
                                    type: "select",
                                    values: {
                                        "正方形": "square",
                                        "円形": "circle",
                                    },
                                    defaultValue: "square",
                                }),
                            },
                            initparams: {
                                delta_a: new NamedForm({
                                    name: "delta_a",
                                    lname: "$\\Delta a$",
                                    type: "number",
                                    units: {
                                        "mm": 1e-3,
                                        "μm": 1e-6,
                                        "nm": 1e-9,
                                    },
                                    defaultUnit: "nm",
                                    required: false,
                                }),
                                RnA: new NamedForm({
                                    name: "RnA",
                                    lname: "$R_{\\rm N}A$",
                                    type: "number",
                                    units: {
                                        "mΩcm²": 1e-3,
                                        "μΩcm²": 1e-6,
                                        "nΩcm²": 1e-9,
                                    },
                                    defaultUnit: "nm",
                                    required: false,
                                }),
                            },
                        },
                        "RnA-d": {
                            formulaModal: new Modal({
                                style: { width: "min-content", padding: "0 16px" },
                                innerHTML: String.raw`$$R_{\rm N} A(t) = \frac{2 t A}{3 \sqrt{4 m_{\rm e} E_{\rm g}}} (h / e)^2 \exp \left((2 t / \hbar) \sqrt{4 m_{\rm e} E_{\rm g}} \right)$$`,
                            }),
                            initparams: {
                                Eg: new NamedForm({
                                    name: "Eg",
                                    lname: "$E_{\\rm g}$",
                                    type: "number",
                                    units: {
                                        "eV": 1,
                                        "meV": 1e-3,
                                    },
                                    defaultUnit: "eV",
                                    required: false,
                                }),
                                A: new NamedForm({
                                    name: "A",
                                    lname: "$A$",
                                    type: "number",
                                    required: false,
                                }),
                            },
                        },
                        "Ic12-Ibias": {
                            formulaModal: new Modal({
                                style: { width: "min-content", padding: "0 16px" },
                                innerHTML: String.raw`$$\Phi_{\rm ex} + L_1 I_1 - L_2 I_2+ \frac{\Phi}{2\pi} \left( \arcsin \frac{I_1}{I_{\rm c1}} - \arcsin \frac{I_2}{I_{\rm c2}} \right) = n \Phi_0 \\\Phi_{\rm ex} = \frac{\Phi_0}{\Delta I} \left( I_{\rm bias} - I_{\rm offset} \right) ,\  I_1 + I_2 = I$$`,
                            }),
                            options: {
                                model: new NamedForm({
                                    name: "model",
                                    lname: "モデル",
                                    type: "select",
                                    values: {
                                        "線形近似": "linear",
                                        "厳密": "strict",
                                    },
                                    defaultValue: "linear",
                                }),
                                n_max: new NamedForm({
                                    name: "n_max",
                                    lname: "$n_{\\rm max}$",
                                    type: "number",
                                    step: 1,
                                    min: 0,
                                    defaultValue: 5,
                                }),
                                symmetricL: new NamedForm({
                                    name: "symmetricL",
                                    lname: "$L_1=L_2$",
                                    type: "checkbox",
                                    defaultValue: false,
                                    props: { style: { margin: "0.25em 0" } },
                                }),
                                symmetricIc: new NamedForm({
                                    name: "symmetricIc",
                                    lname: "$I_{\\rm c1}=I_{\\rm c2}$",
                                    type: "checkbox",
                                    defaultValue: false,
                                    props: { style: { margin: "0.25em 0" } },
                                }),
                                outline_only: new NamedForm({
                                    name: "outline_only",
                                    lname: "アウトラインのみ",
                                    type: "checkbox",
                                    defaultValue: true,
                                    props: { style: { margin: "0.25em 0" } },
                                }),
                            },
                            initparams: {
                                deltaI: new NamedForm({
                                    name: "deltaI",
                                    lname: "$\\Delta I$",
                                    type: "number",
                                    units: {
                                        "mA": 1e-3,
                                        "μA": 1e-6,
                                        "nA": 1e-9,
                                    },
                                    defaultUnit: "μA",
                                    required: false,
                                }),
                                Ioffset: new NamedForm({
                                    name: "Ioffset",
                                    lname: "$I_{\\rm offset}$",
                                    type: "number",
                                    units: {
                                        "mA": 1e-3,
                                        "μA": 1e-6,
                                        "nA": 1e-9,
                                    },
                                    defaultUnit: "μA",
                                    required: false,
                                }),
                                L: new NamedForm({
                                    name: "L",
                                    lname: "$L$",
                                    type: "number",
                                    units: {
                                        "μH": 1e-6,
                                        "nH": 1e-9,
                                        "pH": 1e-12,
                                        "fH": 1e-15,
                                    },
                                    defaultUnit: "pH",
                                    required: false,
                                }),
                                L1: new NamedForm({
                                    name: "L1",
                                    lname: "$L_1$",
                                    type: "number",
                                    units: {
                                        "μH": 1e-6,
                                        "nH": 1e-9,
                                        "pH": 1e-12,
                                        "fH": 1e-15,
                                    },
                                    defaultUnit: "pH",
                                    required: false,
                                }),
                                L2: new NamedForm({
                                    name: "L2",
                                    lname: "$L_2$",
                                    type: "number",
                                    units: {
                                        "μH": 1e-6,
                                        "nH": 1e-9,
                                        "pH": 1e-12,
                                        "fH": 1e-15,
                                    },
                                    defaultUnit: "pH",
                                    required: false,
                                }),
                                Ic: new NamedForm({
                                    name: "Ic",
                                    lname: "$I_{\\rm c}$",
                                    type: "number",
                                    units: {
                                        "mA": 1e-3,
                                        "μA": 1e-6,
                                        "nA": 1e-9,
                                    },
                                    defaultUnit: "μA",
                                    required: false,
                                }),
                                Ic1: new NamedForm({
                                    name: "Ic1",
                                    lname: "$I_{\\rm c1}$",
                                    type: "number",
                                    units: {
                                        "mA": 1e-3,
                                        "μA": 1e-6,
                                        "nA": 1e-9,
                                    },
                                    defaultUnit: "μA",
                                    required: false,
                                }),
                                Ic2: new NamedForm({
                                    name: "Ic2",
                                    lname: "$I_{\\rm c2}$",
                                    type: "number",
                                    units: {
                                        "mA": 1e-3,
                                        "μA": 1e-6,
                                        "nA": 1e-9,
                                    },
                                    defaultUnit: "μA",
                                    required: false,
                                }),
                            },
                            update: () => {
                                const { symmetricL, symmetricIc } = this.options;
                                const { L, L1, L2, Ic, Ic1, Ic2 } = this.initparams;

                                const setHidden = (form, disabled) => {
                                    form.disabled = disabled;
                                    form.elem.hidden = disabled;
                                };
                                
                                setHidden(L, !symmetricL.value);
                                setHidden(L1, symmetricL.value);
                                setHidden(L2, symmetricL.value);
                                
                                setHidden(Ic, !symmetricIc.value);
                                setHidden(Ic1, symmetricIc.value);
                                setHidden(Ic2, symmetricIc.value);
                            },
                        },
                    };
                    #buttons = {
                        useResult: createElement("button", {
                            style: { flexGrow: "1", fontSize: "0.8em" },
                            onclick: () => {
                                if (this.mode === "I-V" && !("I-V" in this.#outerThis.target.fits)) {
                                    const { Vg, Q } = this.#outerThis.target.data;

                                    this.fromObject({ Vg, Vg_plus: Vg, Q });
                                }
                                else {
                                    this.fromObject(this.#outerThis.target.fits[this.mode]?.params);
                                }

                                this.#onchange();
                            },
                        }, "結果を入力"),
                        delete: createElement("button", {
                            style: { flexGrow: "1", fontSize: "0.8em" },
                            onclick: () => {
                                for (const form of Object.values(this.initparams)) {
                                    form.value = undefined;
                                }

                                this.#onchange();
                            },
                        }, "すべて消去"),
                    };

                    constructor(outerThis) {
                        this.#outerThis = outerThis;
                        
                        // Latexコンパイル用
                        new Popup(null,
                            ...Object.values(this.#modes)
                                    .map(({ options, initparams }) => Object.values({ ...options, ...initparams }))
                                    .flat()
                                    .map(({ elem }) => elem),
                        );
                    }

                    get mode() {
                        return this.#mode;
                    }

                    set mode(mode) {
                        this.#mode = mode;

                        while (this.elem.firstChild) this.elem.firstChild.remove();
                        this.elem.append(
                            ...Object.values(this.options).map(({ elem }) => elem),

                            createElement("h3", { style: { marginTop: "0.25em" } }, "初期値"),
                            createElement("div", {
                                class: "align-center",
                                style: { margin: "4px 0", gap: "8px" },
                            }, this.#buttons.useResult, this.#buttons.delete),
                            ...Object.values(this.initparams).map(({ elem }) => elem),
                        );

                        for (const form of this.list) {
                            form.onchange = () => this.#onchange();
                        }

                        this.#onchange();
                    }

                    get formulaModal() {
                        return this.#modes[this.mode].formulaModal;
                    }

                    get options() {
                        return this.#modes[this.mode].options ?? {};
                    }

                    get initparams() {
                        return this.#modes[this.mode].initparams ?? {};
                    }

                    get list() {
                        return [...Object.values(this.options), ...Object.values(this.initparams)];
                    }

                    toObject() {
                        return Object.fromEntries(
                            this.list.filter(({ disabled }) => !disabled).map(({ name, value }) => [name, value])
                        );
                    }

                    fromObject(object = {}) {
                        for (const form of this.list) {
                            if (form.name in object) form.value = object[form.name];
                        }

                        this.#onchange();
                    }

                    onchangeTarget() {
                        this.#modes[this.mode].onchangeTarget?.();
                    }

                    isValid() {
                        return this.list.filter(({ disabled }) => !disabled).every(({ isValid }) => isValid);
                    }

                    #onchange() {
                        this.#modes[this.mode].update?.();
                        this.#outerThis.#execbutton.update();
                    }
                }(this);
                #execbutton = createElement("button", {
                    id: "fit-button",
                    class: "large",
                    style: { flexShrink: "0" },
                    title: "フィットの実行/停止",
                    onclick: () => this.#exec(),
                    update: () => {
                        if (this.running) return;

                        this.#execbutton.inert = !this.#params.isValid();
                    },
                }, "実行");
                #spinner = createElement("div", {
                    class: "spinner",
                    style: { flexShrink: "0" },
                    hidden: true,
                });
                #message = createElement("div", { style: { fontSize: "0.75em" } });
                #target;
                #mode;
                #abortController;
                #running = false;
                
                constructor() {
                    this.#menu.elem.append(
                        createElement("div", { style: { flexShrink: "0", padding: "8px 8px 0" } },
                            createElement("div", { class: "align-center" },
                                createElement("div", {
                                    class: "align-center",
                                    style: { cursor: "pointer" },
                                    onclick: e => {
                                        this.#menu.fixed = true;
                                        this.#modeSelector.onclose = () => {
                                            this.#menu.elem.focus();
                                            this.#menu.fixed = false;
                                        };

                                        const { left, bottom } = this.#title.getBoundingClientRect();

                                        this.#modeSelector.open({ x: left, y: bottom, xmargin: -4 });
                                    },
                                },
                                    this.#title,
                                    createElement("div", { 
                                        style: { marginLeft: "4px" },
                                        innerHTML: '<svg width="10" height="10" viewbox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M 1 4 l 4 4 l 4 -4"/></svg>',
                                    }),
                                ),
                                this.#formulaButton,
                            ),
                            this.#targetname,
                        ),

                        createElement("div", { style: { flexGrow: "1", overflowY: "auto", padding: "4px 8px" } },
                            this.#params.elem,
                        ),
                        
                        createElement("div", { class: "align-center", style: { gap: "4px", padding: "4px 8px 8px" } },
                            this.#execbutton,
                            this.#spinner,
                            this.#message,
                        ),
                    );

                    this.#modeSelector.onchange();
                }

                get running() {
                    return this.#running;
                }

                set running(input) {
                    this.#running = input;
                    this.#spinner.hidden = !input;

                    if (input) {
                        this.#execbutton.textContent = "停止";
                        this.#execbutton.onclick = () => this.#abortController.abort();
                    }
                    else {
                        this.#execbutton.update();
                        this.#execbutton.textContent = "実行";
                        this.#execbutton.onclick = () => this.#exec();
                    }
                }

                get mode() {
                    return this.#mode;
                }

                set mode(mode) {
                    this.#mode = mode;

                    this.#params.mode = mode;
                    this.#formulaButton.hidden = !this.#params.formulaModal;
                }

                get target() {
                    return this.#target;
                }

                set target(target) {
                    this.#target = target;

                    this.#modeSelector.update();
                    if (this.#modeSelector.options[
                        Object.values(this.#modeSelector.values).indexOf(this.#modeSelector.value)
                    ].inert) {
                        const index = this.#modeSelector.options.findIndex(option => !option.inert);

                        if (index !== -1) {
                            this.#modeSelector.value = Object.values(this.#modeSelector.values)[index];
                            this.#modeSelector.onchange();
                        }
                    }

                    this.#params.onchangeTarget();
                    this.#targetname.title = target.displayName;
                    this.#targetname.textContent = target.displayName;
                }

                get data() {
                    if (this.mode === "Ic12-Ibias") {
                        const { Ibias: x, Ic1: y1, Ic2: y2 } = this.target.data
                        
                        return { x, y1, y2 };
                    }
                    else {
                        const [ykey, xkey] = this.mode.split("-");
                        const { [xkey]: x, [ykey]: y } = this.target.data;

                        return { x, y };
                    }
                }

                get params() {
                    return { mode: this.mode, ...this.#params.toObject()};
                }

                open(pos) {
                    this.#menu.open(pos);
                }

                async #exec() {
                    const mode = this.mode;
                    const target = this.target;

                    this.running = true;
                    target.running = true;
                    this.#message.innerText = "";
                    this.#abortController = new AbortController();

                    try {
                        const response = await fetch("/fit", {
                            method: "POST",
                            signal: this.#abortController.signal,
                            body: JSON.stringify({...this.params, ...this.data}),
                        });

                        for await (const line of readlines(response)) {
                            const { message, params, x, y, error } = JSON.parse(line);
                            if (error) throw error;

                            if (message) this.#message.innerText = message;
                            if (params && x && y) {
                                target.fits[mode] = { params, x, y };
                                target.saved = false;

                                if (plot.targets.includes(target)) plot.update();
                            }
                        }
                    }
                    catch (error) {
                        if (error.name !== "AbortError") {
                            console.error(error);

                            if (typeof error === "string") alert([error.split("\n").slice(-2)[0], "", error].join("\n"));
                        }
                    }

                    this.running = false;
                    target.running = false;
                }
            }();
            #infoModal = new class {
                #target;
                #modal = new Modal({ style: {
                    minWidth: "300px",
                    maxHeight: "80vh",

                    display: "flex",
                    flexDirection: "column",
                    overflowY: "auto",
                }});
                #targetname = createElement("h2", {
                    style: {
                        flexShrink: "0",
                        marginBottom: "4px",

                        color: "var(--text-secondary)",
                        overflow: "hidden",
                        padding: "8px 12px 0",
                        textOverflow: "ellipsis",
                        whiteSpace: "nowrap",
                    },
                });
                #content = createElement("div", {
                    style: {
                        flexGrow: "1",
                        overflowY: "auto",
                        padding: "4px 12px 8px",
                        userSelect: "text",
                    },
                });

                constructor() {
                    this.#modal.elem.append(
                        this.#targetname,
                        this.#content,
                    );
                }

                get target() {
                    return this.#target;
                }

                set target(target) {
                    this.#target = target;

                    this.#targetname.textContent = target.displayName;
                    this.#targetname.title = target.displayName;
                    this.#content.innerText = target.toText("txt");
                }

                open() {
                    this.#modal.open();
                }
            }();
            #saver = new class {
                buttons = createElement("div", { style: { display: "inline-flex" } });
                #savebutton = createElement("button", {
                    class: "large",
                    style: {
                        borderTopRightRadius: "0",
                        borderBottomRightRadius: "0",
                    },
                    title: "測定結果を保存(Ctrl+S)",
                    onclick: () => this.exec(),
                }, "保存");
                #menubutton = createElement("button", {
                    class: "icon",
                    style: {
                        borderLeft: "none",
                        borderTopLeftRadius: "0",
                        borderBottomLeftRadius: "0",
                    },
                    title: "保存のオプション",
                    innerHTML: '<svg width="10" height="10" viewbox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M 1 4 l 4 4 l 4 -4"/></svg>',
                    onclick: () => {
                        const { right, top } = this.#menubutton.getBoundingClientRect();
                        this.#menu.open({ x: right, y: top, xanchor: "right", yanchor: "bottom", ymargin: 4 });
                    },
                });
                #menu = new Popup({ style: { padding: "8px" } });
                #dirpickbutton = createElement("button", {
                    style: { marginTop: "0.25em" },
                    title: "クリックでフォルダーを選択",
                    onclick: async () => {
                        try {
                            this.#dirHandle = await showDirectoryPicker({ mode: "readwrite" });

                            this.#dirpickbutton.textContent = "/" + this.#dirHandle.name;
                        }
                        catch (error) {
                            if (!(error instanceof DOMException)) throw error;
                        }
                    },
                }, "フォルダーを選択");
                #targetselector = createElement("select", {
                    style: { marginLeft: 0 },
                    onchange: () => {
                        this.#targets = [
                            results.#list.filter(({ group }) => !group),
                            results.#list.filter(({ group }) => !group).filter(result => !result.saved),
                            results.selected.filter(({ group }) => !group),
                        ][this.#targetselector.selectedIndex];
                    },
                }, ...["全て", "未保存のみ", "選択中のみ"].map(
                    (name, i) => createElement("option", { selected: i === 1 }, name)
                ));
                #formatselector = createElement("div", {
                    style: {
                        display: "grid",
                        gridTemplateColumns: "repeat(3, 1fr)",
                        columnGap: "10px",
                    },
                    onchange: () => {
                        const formats = [];
                        for (const input of this.#formatselector.querySelectorAll("input")) {
                            if (input.checked) formats.push(input.dataset.value);
                        }

                        this.#formats = formats;
                    },
                }, ...["json", "csv", "txt", "png", "svg"].map(
                    format => createElement("label", { class: "align-center" },
                        createElement("input", {
                            type: "checkbox",
                            dataset: { value: format },
                            checked: ["json", "csv", "txt"].includes(format),
                            onchange: () => this.#formatselector.onchange(),
                        }),
                        format,
                    )),
                );
                #dirHandle;
                #targets;
                #formats;

                constructor() {
                    this.buttons.append(
                        this.#savebutton,
                        this.#menubutton,
                    );
                    
                    this.#menu.elem.append(
                        createElement("div", null, "保存先"),
                        this.#dirpickbutton,
                        
                        createElement("div", { style: { marginTop: "10px" } }, "項目"),
                        this.#targetselector,

                        createElement("div", { style: { marginTop: "10px" } }, "形式"),
                        this.#formatselector,
                    );
                }

                async exec() {
                    this.#targetselector.onchange();
                    this.#formatselector.onchange();

                    if (!this.#targets.length || !this.#formats.length) {
                        logger.log("保存する項目がありません");
                        return;
                    }

                    if (!this.#dirHandle) await this.#dirpickbutton.onclick();
                    if (!this.#dirHandle) return;
                    
                    results.#spinner.hidden = false;
                    for (const result of this.#targets) {
                        for (const format of this.#formats) {
                            await this.#save(result, format);
                        }
                    }
                    results.#spinner.hidden = true;
                }

                async #save(result, format) {
                    const baseName = (result.displayName).replaceAll(/[\\/:*?"<>|]/g, "_");
                    let fileName;

                    try {
                        let count = 0;

                        while (true) {
                            fileName = `${baseName}${count ? ` (${count})` : ""}.${format}`;
                            await this.#dirHandle.getFileHandle(fileName);
                            count += 1;
                        }
                    }
                    catch (error) {
                        if (!(error instanceof DOMException)) throw error;

                        const fileHandle = await this.#dirHandle.getFileHandle(fileName, { create: true });
                        const writable = await fileHandle.createWritable();
                        if (["json", "csv", "txt"].includes(format)) {
                            await writable.write(result.toText(format));
                        }
                        else {
                            results.selected = [result];
                            await writable.write(await plot.toImage(format));
                        }
                        await writable.close();

                        if (format === "json") result.saved = true;
                        logger.log(`${fileHandle.name}を保存しました`);
                    }
                }
            }();
            
            #ResultBase = class {
                #saved = false;
                #name;
                elem = createElement("div", {
                    class: "result clickable",
                    tabIndex: "0",
                    draggable: true,
                });
                #nameElem = createElement("div", { class: "name" }, createElement("span"), createElement("span"));       
                #buttons = createElement("div", { class: "buttons", onclick: e => e.stopPropagation() },
                    createElement("div", {
                        title: "編集",
                        innerHTML: '<svg width="14" height="14" viewbox="0 0 10 10" fill="none" stroke="currentColor"><path d="M 1 9 v -1.5 l 6 -6 l 1.5 1.5 l -6 6 z M 6 3 l 1.5 1.5"/></svg>',
                        onclick: () => this.edit(),
                    }),
                    createElement("div", {
                        title: "フィット",
                        innerHTML: '<svg width="14" height="14" viewBox="0 0 100 100" fill="currentColor" stroke="none"><path d="M 10 65 l 80 -40 v 10 l -80 40 z M 20 40 m 0 -10 a 10 10 0 1 1 -0.01 0 M 70 15 m 0 -10 a 10 10 0 1 1 -0.01 0 M 55 75 m 0 -10 a 10 10 0 1 1 -0.01 0"/></svg>',
                        onclick: () => this.fit(),
                    }),
                    createElement("div", {
                        title: "名前の変更",
                        innerHTML: '<svg width="14" height="14" viewbox="0 0 10 10" fill="none" stroke="currentColor"><rect x="1" y="2" width="8" height="6" rx="1"></rect><path d="M 6 0 h 2 h -1 v 10 h -1 h 2"></path><text x="3" y="6.4" font-size="4" stroke-width="0.4">A</text></svg>',
                        onclick: () => this.rename(),
                    }),
                    createElement("div", {
                        title: "削除",
                        innerHTML: '<svg width="14" height="14" viewbox="0 0 10 10"><path fill="none" stroke="currentColor" d="M 1 1 L 9 9 M 1 9 L 9 1"></path></svg>',
                        onclick: () => this.delete(),
                    }),
                );

                constructor({ name, filename, timestamp }) {
                    this.filename = filename;
                    this.timestamp = timestamp;
                    this.date = new Date(this.timestamp * 1000);
                    this.name = name ?? filename?.split(".")?.slice(0, -1)?.join(".");

                    this.elem.append(
                        this.#nameElem,
                        this.#buttons,
                    );
                }

                set running(running) {
                    if (running) this.elem.classList.add("running");
                    else this.elem.classList.remove("running");
                }

                get saved() {
                    return this.#saved;
                }

                set saved(saved) {
                    this.#saved = saved;

                    if (saved) this.elem.classList.add("saved");
                    else this.elem.classList.remove("saved");
                    
                    this.#nameElem.title = (
                        (!this.saved ? "[未保存]\n" : "")
                        + (this.name ? `${this.name}\n` : "")
                        + (this.filename ? `ファイル名: ${this.filename}\n` : "")
                        + `実行日時: ${this.date.toLocaleString()}`
                    );
                }

                get name() {
                    return this.#name;
                }

                set name(name) {
                    this.#name = name;
                    
                    this.#nameElem.title = (
                        (!this.saved ? "[未保存]\n" : "")
                        + (this.name ? `${this.name}\n` : "")
                        + (this.filename ? `ファイル名: ${this.filename}\n` : "")
                        + `実行日時: ${this.date.toLocaleString()}`
                    );

                    const [flexible, fixed] = this.#nameElem.children;
                    flexible.textContent = this.displayName.slice(0, -16);
                    fixed.textContent = this.displayName.slice(-16);
                }

                get displayName() {
                    return this.name || this.filename?.split(".")?.slice(0, -1)?.join(".") || this.date.toLocaleString();
                }

                edit() {
                    const { left, top, height } = this.elem.getBoundingClientRect();

                    results.#editor.targets = [this];
                    results.#editor.open({ x: left, y: top + height / 2, xanchor: "right", xmargin: 4, ymargin: -height / 2 });
                }

                fit() {
                    results.#fitter.target = this;
                    
                    const { left, top, height } = this.elem.getBoundingClientRect();
                    results.#fitter.open({ x: left, y: top + height / 2, xanchor: "right", xmargin: 4, ymargin: -height / 2 });
                }

                restore() {
                    if (!Object.keys(this.params).length) {
                        logger.log("復元できる設定がありません");
                        return;
                    }

                    const params = measurement.params;

                    const action = {
                        undo: () => {
                            measurement.params = params;
                        },
                        redo: () => {
                            measurement.params = this.params
                        },
                    };

                    const log = createElement("div", {
                        class: "align-center",
                        style: { width: "100%", justifyContent: "space-between" },
                    },
                        `${this.displayName}の設定を復元しました`,
                        createElement("div", {
                            class: "clickable",
                            style: {
                                marginLeft: "20px",

                                borderRadius: "4px",
                                fontWeight: "bold",
                                padding: "0 2px",
                            },
                            onclick: () => {
                                undoManager.undo(action);
                                log.parentElement.remove();
                            },
                        }, "元に戻す"),
                    );
                    logger.log(log);

                    undoManager.addAction(action);
                    action.redo();
                }

                rename() {
                    this.elem.classList.add("rename");

                    const { offsetLeft, offsetWidth } = this.#nameElem;
                    const { offsetTop, offsetHeight } = this.elem;

                    const renamer = createElement("input", {
                        style: {
                            position: "absolute",
                            left: `${offsetLeft}px`,
                            top: `${offsetTop}px`,
                            width: `${offsetWidth}px`,
                            height: `${offsetHeight}px`,
                            margin: "0",
                            zIndex: "1",

                            backgroundColor: "transparent",
                            border: "none",
                            borderRadius: "0",
                            fontSize: "1em",
                            padding: "0",
                            outline: "none",
                        },
                        type: "text",
                        value: this.name ?? "",
                        attrs: { list: "namelist" },
                        onkeydown: e => {
                            e.stopPropagation();

                            if (e.keyCode === 13) this.elem.focus();
                        },
                        onblur: e => {
                            renamer.remove();
                            this.elem.classList.remove("rename");

                            if (this.name !== renamer.value) {
                                this.name = renamer.value;
                                
                                results.#namelist.update();
                                if (plot.targets.includes(this)) plot.updateData();
                            }
                        },
                    });

                    results.#listElem.append(renamer);

                    renamer.focus();
                    renamer.select();
                }

                delete() {
                    results.remove(this);
                }
            };
            Result = class extends this.#ResultBase {
                #group = null;
                
                constructor({ name, filename, timestamp, params, calcparams, data, fits }){
                    super({ name, filename, timestamp });

                    this.params = params ?? {};
                    if ("channel_I" in params && "I" in data) {
                        let { Gain_I } = this.params;

                        Object.defineProperty(this.params, "Gain_I", {
                            get: () => Gain_I,
                            set: value => {
                                if (Gain_I !== undefined) {
                                    const factor = Gain_I / value;

                                    this.rawdata.I = this.rawdata.I.map(v => v * factor);
                                    this.calcparams.Ioffset *= factor;
                                    this.calc();
                                }

                                Gain_I = value;
                            },
                        });
                    }
                    if ("channel_V" in params && "V" in data) {
                        let { Gain_V, R_I } = this.params;

                        Object.defineProperty(this.params, "Gain_V", {
                            get: () => Gain_V,
                            set: value => {
                                if (Gain_V !== undefined) {
                                    const factor = Gain_V / value;

                                    this.rawdata.V = this.rawdata.V.map(v => v * factor);
                                    this.calcparams.Voffset *= factor;
                                    this.calc();
                                }

                                Gain_V = value;
                            },
                        });
                        Object.defineProperty(this.params, "R_I", {
                            get: () => R_I,
                            set: value => {
                                if (R_I !== undefined) {
                                    const factor = R_I / value;

                                    this.rawdata.I = this.rawdata.I.map(v => v * factor);
                                    this.calcparams.Ioffset *= factor;
                                    this.calc();
                                }

                                R_I = value;
                            },
                        });
                    }

                    this.calcparams = {
                        ...Object.fromEntries(
                            Object.entries(info.calcparams)
                                  .map(([key, { defaultValue }]) => [key, defaultValue])
                        ),
                        ...calcparams,
                    };
                    this.rawdata = data;

                    const outerThis = this;
                    this.calcdata = {
                        get V() {
                            let Vraw;
                            
                            if ("V" in outerThis.rawdata) {
                                Vraw = outerThis.rawdata.V;
                            }
                            else {
                                const { channel_V, Gain_V } = outerThis.params;
                                const [chAName, chBName] = channel_V.split("-");
                                const { [chAName]: chA = [], [chBName]: chB = [] } = outerThis.rawdata;

                                Vraw = chA.map((_, i) => {
                                    return !chB.length ? chA[i] / Gain_V : chA[i] - chB[i];
                                });
                            }

                            return Vraw.map(v => v - outerThis.calcparams.Voffset);
                        },
                        get I() {
                            let Iraw;
                            
                            if ("I" in outerThis.rawdata) {
                                Iraw = outerThis.rawdata.I;
                            }
                            else {
                                const { channel_I, Gain_I, R_I } = outerThis.params;
                                const [chAName, chBName] = channel_I.split("-");
                                const { [chAName]: chA = [], [chBName]: chB = [] } = outerThis.rawdata;

                                Iraw = chA.map((_, i) => {
                                    return (!chB.length ? chA[i] / Gain_I : chA[i] - chB[i]) / R_I;
                                });
                            }

                            return Iraw.map(v => v - outerThis.calcparams.Ioffset);
                        },
                        get t() {
                            if (outerThis.rawdata.preamble) {
                                const { xincrement, points } = outerThis.rawdata.preamble;

                                return Array(points).fill().map((_, i) => i * xincrement);
                            }
                        },

                        Ic1: undefined,
                        Ic2: undefined,
                        get Ic12() {
                            return [this.Ic1, this.Ic2];
                        },
                        Ic: undefined,
                        get Jc() {
                            const { A } = outerThis.rawdata;
                            if (A !== undefined) return 1e-4 * this.Ic / A;
                        },

                        Rn: undefined,
                        Rsg: undefined,
                        get Q() {
                            return this.Rsg / this.Rn;
                        },
                        get RnA() {
                            const { A } = outerThis.rawdata;
                            if (A !== undefined) return 1e4 * this.Rn * A;
                        },
                        get rho() {
                            const { A, d } = outerThis.rawdata;
                            if (A !== undefined && d !== undefined) return 1e2 * this.Rn * A / d;
                        },
                        get IcRn() {
                            return this.Ic * this.Rn;
                        },

                        dIdV: undefined,
                        Vg: undefined,
                        get Ic_th() {
                            return Math.PI / 4 * this.Vg / this.Rn;
                        },
                        get Jc_th() {
                            const { A } = outerThis.rawdata;
                            if (A !== undefined) return 1e-4 * this.Ic_th / A;
                        },

                        get beta_c() {
                            return outerThis.fits["I-V"]?.params?.beta_c;
                        },
                        get C() {
                            const { Ic, IcRn, beta_c } = outerThis.fits["I-V"]?.params ?? {};

                            if (Ic !== undefined && IcRn !== undefined && beta_c !== undefined) {
                                const phi0 = 2.0678338484619295e-15;

                                return phi0 / (2 * Math.PI) * beta_c * Ic / IcRn**2;
                            }
                        },
                        get Cs() {
                            const { C } = this;
                            const { A } = outerThis.rawdata;

                            if (C !== undefined && A !== undefined) return C / A;
                        },
                        get eps() {
                            const { C } = this;
                            const { A, d } = outerThis.rawdata;

                            if (C !== undefined && A !== undefined && d !== undefined) return C / A * d;
                        },
                        get eps_r() {
                            const { eps } = this;
                            const eps0 = 8.85418782e-12;

                            if (eps !== undefined) return eps / eps0;
                        },
                    };

                    this.calc();

                    this.fits = fits ?? {};
                }

                get group() {
                    return this.#group;
                }

                set group(group) {
                    this.#group = group;

                    if (group) {
                        this.elem.classList.add("group-item");
                        this.elem.draggable = false;
                    }
                    else {
                        this.elem.classList.remove("group-item");
                        this.elem.draggable = true;
                    }
                }

                get saved() {
                    return super.saved;
                }

                set saved(saved) {
                    super.saved = saved;

                    if (this.group) this.group.onchangeSaved();
                }

                get data() {
                    const { date } = this;
                    const { T, Ibias, A, d } = this.rawdata;

                    return Object.defineProperties(
                        { date, T, Ibias, A, d },
                        Object.getOwnPropertyDescriptors(this.calcdata),
                    );
                }

                calc() {
                    const avg = (a = []) => a.reduce((pre, cur) => pre + cur, 0) / a.length;
                    const { A, d, Voffset, Ioffset, V_Ic, Vn, Vsg, Vg_min, Vg_max, N_SMA } = this.calcparams;
                    const { V, I } = this.calcdata;
                    
                    // Ic
                    let IcIndex1 = -1, IcIndex2 = -1;
                    I.slice(0, -1).forEach((i, index) => {
                        if (V[index] < V_Ic && V_Ic < V[index + 1]) {
                            if (IcIndex1 === -1 || I[IcIndex1] < i) IcIndex1 = index;
                        }
                        else if (V[index] > -V_Ic && -V_Ic > V[index + 1]) {
                            if (IcIndex2 === -1 || I[IcIndex2] > i) IcIndex2 = index;
                        }
                    });
                    const Ic1 = I[IcIndex1] ?? NaN;
                    const Ic2 = I[IcIndex2] ?? NaN;
                    const Ic = avg([Ic1, -Ic2].filter(Number.isFinite));
                    Object.assign(this.calcdata, { Ic1, IcIndex1, Ic2, IcIndex2, Ic });

                    // Rn, Rsg
                    const nearest = Vtarget => V.reduce((inear, v, i) => (
                        (Vtarget > 0 ? v > -Vtarget * 0.5 : v < Vtarget * 0.5)
                        && (inear === -1 || Math.abs(v - Vtarget) < Math.abs(V[inear] - Vtarget))
                    ) ? i : inear, -1);
                    const [RnIndex1, RnIndex2] = [nearest(Vn), nearest(-Vn)];
                    const Rn = (
                        RnIndex1 !== -1 && RnIndex2 !== -1 ? (V[RnIndex1] - V[RnIndex2]) / (I[RnIndex1] - I[RnIndex2])
                        : RnIndex1 !== -1 ? V[RnIndex1] / I[RnIndex1]
                        : RnIndex2 !== -1 ? V[RnIndex2] / I[RnIndex2]
                        : NaN
                    );
                    Object.assign(this.calcdata, { Rn, RnIndex1, RnIndex2 });
                    const [RsgIndex1, RsgIndex2] = [nearest(Vsg), nearest(-Vsg)];
                    const Rsg = (
                        RsgIndex1 !== -1 && RsgIndex2 !== -1 ? (V[RsgIndex1] - V[RsgIndex2]) / (I[RsgIndex1] - I[RsgIndex2])
                        : RsgIndex1 !== -1 ? V[RsgIndex1] / I[RsgIndex1]
                        : RsgIndex2 !== -1 ? V[RsgIndex2] / I[RsgIndex2]
                        : NaN
                    );
                    Object.assign(this.calcdata, { Rsg, RsgIndex1, RsgIndex2 });

                    // dVdI, Vg
                    const movingAvg = (a, n = 1) => {
                        return a.map((_, i) => avg(a.slice(
                            Math.max(0, i - Math.floor(n / 2)), Math.min(i + n - Math.floor(n / 2), a.length)
                        )));
                    };
                    const [Vsmooth, Ismooth] = [movingAvg(V, N_SMA), movingAvg(I, N_SMA)];
                    const [Vmin, Vmax] = [Math.min(...Vsmooth), Math.max(...Vsmooth)];
                    const [Vg_min1, Vg_min2] = Vg_min < 0 ? [Vmin - Vg_min, Vmax + Vg_min] : [-Vg_min, Vg_min];
                    const [Vg_max1, Vg_max2] = Vg_max < 0 ? [Vmin - Vg_max, Vmax + Vg_max] : [-Vg_max, Vg_max];
                    const dIdV = movingAvg(V.slice(0, -1).map((v, i) => {
                        if (Vg_max1 < v && v < Vg_min1 || Vg_min2 < v && v < Vg_max2) {
                            const dI = Ismooth[i + 1] - Ismooth[i];
                            const dV = Vsmooth[i + 1] - Vsmooth[i];

                            return dV !== 0 ? dI / dV : NaN;
                        }
                        else return NaN;
                    }), N_SMA);
                    
                    let VgIndex1 = -1;
                    let VgIndex2 = -1;
                    V.slice(0, -1).forEach((v, i) => {
                        if (Number.isNaN(dIdV[i])) return;

                        if (v >= 0) {
                            if (VgIndex1 === -1 || dIdV[i] > dIdV[VgIndex1]) VgIndex1 = i;
                        }
                        else {
                            if (VgIndex2 === -1 || dIdV[i] > dIdV[VgIndex2]) VgIndex2 = i;
                        }
                    });
                    const Vg = avg([V[VgIndex1], -V[VgIndex2]].filter(Number.isFinite));
                    Object.assign(this.calcdata, { dIdV, Vg, VgIndex1, VgIndex2 });
                }

                has(key) {
                    if (key === "t") return !!this.rawdata.preamble;
                    if (key === "date") return !!this.timestamp;
                    if (key === "Ic12") return this.has("Ic1") || this.has("Ic2");
                    return [this.data[key]].flat().some(Number.isFinite);
                }

                toObject() {
                    const { name, timestamp, params, calcparams, rawdata, fits } = this;

                    return { name, timestamp, params, calcparams, data: rawdata, fits };
                }

                toText(format = "json") {
                    if (format === "json") {
                        return JSON.stringify(this.toObject());
                    }
                    
                    else if (format === "csv") {
                        const { V, I } = this.calcdata;

                        return "V (V),I (A)\n" + V.map((_, i) => `${round(V[i])},${round(I[i])}`).join("\n");
                    }

                    else {
                        const toString = ({ name, value, unit = "", SIpow, precision }) => {
                            if (!Number.isFinite(value)) {
                                if (value !== undefined) {
                                    return `${name}: ${Number.isNaN(value) ? "--" : value}` + (unit && ` ${unit}`);
                                }
                                else return "";
                            }
                            else {   
                                if (unit) {
                                    const SIprefix = getSIPrefix(round(value), SIpow);

                                    return `${name}: ${round(value / SIprefix.value).toPrecision(precision)} ${SIprefix.name + unit}`;
                                }
                                else return `${name}: ${round(value).toPrecision(precision)}`;
                            }
                        };

                        let output = `[実行日時]\n${this.date.toLocaleString()}`;

                        output += "\n\n[データ]\n";
                        output += Object.entries(this.data)
                                        .filter(([key]) => key in info.data && !info.data[key].noText)
                                        .map(([key, value]) => toString({ value, ...info.data[key], precision: 4 }))
                                        .filter(s => s)
                                        .join("\n");

                        output += `\n\n[設定]\n`;
                        output += Object.entries(this.params)
                                        .filter(([key]) => !info.params[key]?.noText)
                                        .map(([key, value]) => (
                                            value !== undefined ? (
                                                key in info.params ? toString({ value, ...info.params[key] })
                                                : `${key}: ${value}`
                                            ) : ""
                                        ))
                                        .filter(s => s)
                                        .join("\n");

                        if (this.rawdata.preamble) {
                            output += "\n\n[オシロ設定]\n" + Object.entries(this.rawdata.preamble)
                                                                .map(([key, value]) => `${key}: ${value}`).join("\n");
                        }

                        output += "\n\n[解析パラメータ]\n";
                        output += Object.entries(this.calcparams)
                                        .map(([key, value]) => toString({ value, ...info.calcparams[key] }))
                                        .filter(s => s)
                                        .join("\n");
                        
                        for (const [key, { params }] of Object.entries(this.fits)) {
                            output += `\n\n[${key === "Ic12-Ibias" ? "I-Φ" : key}フィット]\n`;
                            output += Object.entries(params)
                                            .map(([name, value]) => toString({ value, ...info.fits[key][name], precision: 4 }))
                                            .filter(s => s)
                                            .join("\n");
                        }

                        return output;
                    }
                }
            };
            ResultGroup = class extends this.#ResultBase {
                list = [];
                #expanded = false;
                params = this.#createProxy("params", { reduceValues: true });
                calcparams = this.#createProxy("calcparams", { reduceValues: true });
                rawdata = this.#createProxy("rawdata");
                data = this.#createProxy("data");
                slider = new class {
                    elem = createElement("div", { class: "namedform" });
                    #textElem;
                    #form;

                    constructor() {
                        this.#textElem = createElement("span", { class: "name" });
                        this.#form = createElement("input", {
                            class: "form",
                            type: "range",
                            min: 0,
                            step: 1,
                            oninput: () => {
                                this.onchange();
                            },
                        });

                        this.elem.append(this.#textElem, this.#form);
                    }

                    set text(text) {
                        this.#textElem.innerHTML = text;
                    }

                    get value() {
                        return Number(this.#form.value);
                    }

                    set value(value) {
                        this.#form.value = value;
                    }

                    get max() {
                        return Number(this.#form.max);
                    }

                    set max(max) {
                        this.#form.max = max;
                    }
                }();

                constructor({ name, filename, timestamp, list, fits }) {
                    super({ name, filename, timestamp });

                    this.elem.classList.add("group");
                    this.elem.append(createElement("div", {
                        class: "marker",
                        onclick: e => {
                            e.stopPropagation();

                            this.expanded = !this.expanded;
                        },
                    }));

                    this.slider.update = () => {
                        this.slider.max = this.list.length - 1;
                        this.slider.text = `${this.slider.max < 0 ? 0 : this.slider.value + 1}<small><small>/${this.slider.max + 1}</small></small>`;
                    };

                    this.slider.onchange = () => {
                        this.slider.update();
                        if (plot.targets.includes(this)) plot.updateData();
                    };

                    this.slider.value = 0;
                    this.slider.update();

                    this.fits = fits ?? {};
                    if (list) {
                        this.append(...list.map(object => new results.Result(object)));
                    }
                }

                get expanded() {
                    return this.#expanded;
                }

                set expanded(expanded) {
                    this.#expanded = expanded;

                    if (expanded) {
                        this.elem.classList.add("expanded");
                        results.#insertAfter(this, ...this.list);
                    }
                    else {
                        const firstSelectedIndex = results.selected.findIndex(result => this.list.includes(result));
                        if (firstSelectedIndex !== -1) {
                            results.selected.splice(firstSelectedIndex, 0, this);
                        }

                        this.elem.classList.remove("expanded");
                        results.#remove(...this.list);
                    }
                }

                get saved() {
                    return !this.list ? false : this.list.every(({ saved }) => saved);
                }

                set saved(saved) {
                    super.saved = saved;

                    this.list.forEach(result => result.saved = saved);
                }

                get selected() {
                    return this.list[this.slider.value];
                }

                append(...entries) {
                    entries.forEach(result => {
                        result.group = this;
                    });

                    if (this.expanded) results.#insertAfter(this.list.at(-1) ?? this, ...entries);
                    
                    this.list.push(...entries);

                    this.slider.update();
                    if (this.slider.max === 0 || this.slider.value === this.slider.max - 1) {
                        this.slider.value = this.slider.max;
                        this.slider.onchange();
                    }
                }

                insert(index, ...entries) {
                    if (index < 0 || index >= this.list.length) {
                        this.append(...entries);
                        return;
                    }

                    entries.forEach(result => {
                        result.group = this;
                    });

                    if (this.expanded) results.#insertAfter(this.list[index], ...entries);

                    this.list = [
                        ...this.list.slice(0, index).filter(result => !entries.includes(result)),
                        ...entries,
                        ...this.list.slice(index).filter(result => !entries.includes(result)),
                    ];

                    this.slider.update();
                }

                remove(...entries) {
                    if (this.expanded) results.#remove(...entries);

                    this.list = this.list.filter(result => !entries.includes(result));

                    this.slider.update();
                }

                onchangeSaved() {
                    super.saved = this.saved;
                }

                calc() {
                    for (const result of this.list) {
                        result.calc();
                    }
                }

                delete() {
                    this.expanded = false;

                    super.delete();
                }

                has(key) {
                    return this.list.some(result => result.has(key));
                }

                toObject() {
                    const { name, timestamp, list, fits } = this;

                    return {
                        name,
                        timestamp,
                        list: list.map(result => result.toObject()),
                        fits,
                    };
                }

                toText(format = "json") {
                    if (format === "json") {
                        return JSON.stringify(this.toObject());
                    }
                    
                    else if (format === "csv") {
                        const transpose = a => a.reduce((p, c) => c.length < p.length ? c : p).map((_, c) => a.map(r => r[c]));
                        const entries = Object.entries(info.data).filter(([key, { noText }]) => !noText);
                        const [keys, objects] = transpose(entries);

                        const header = objects.map(({ name, unit }) => `${name} (${unit})`).join(",");
                        const rows = transpose(keys.map(key => this.data[key])).map(values => {
                            return values.map(value => Number.isFinite(value) ? round(value) : "").join(",");
                        });
                        
                        return [header, ...rows].join("\n");
                    }

                    else {
                        const toString = ({ name, value, unit = "", SIpow, precision }) => {
                            if (!Number.isFinite(value)) {
                                if (value !== undefined) {
                                    return `${name}: ${Number.isNaN(value) ? "--" : value}` + (unit && ` ${unit}`);
                                }
                                else return "";
                            }
                            else {   
                                if (unit) {
                                    const SIprefix = getSIPrefix(round(value), SIpow);

                                    return `${name}: ${round(value / SIprefix.value).toPrecision(precision)} ${SIprefix.name + unit}`;
                                }
                                else return `${name}: ${round(value).toPrecision(precision)}`;
                            }
                        };

                        let output = `[実行日時]\n${this.date.toLocaleString()}`;

                        output += `\n\n[設定]\n`;
                        output += Object.entries(this.params)
                                        .filter(([key]) => !info.params[key]?.noText)
                                        .map(([key, value]) => (
                                            value !== undefined ? (
                                                key in info.params ? toString({ value, ...info.params[key] })
                                                : `${key}: ${value}`
                                            ) : ""
                                        ))
                                        .filter(s => s)
                                        .join("\n");

                        output += "\n\n[解析パラメータ]\n";
                        output += Object.entries(this.calcparams)
                                        .map(([key, value]) => toString({ value, ...info.calcparams[key] }))
                                        .filter(s => s)
                                        .join("\n");
                        
                        for (const [key, { params }] of Object.entries(this.fits)) {
                            output += `\n\n[${key === "Ic12-Ibias" ? "I-Φ" : key}フィット]\n`;
                            output += Object.entries(params)
                                            .map(([name, value]) => toString({ value, ...info.fits[key][name], precision: 4 }))
                                            .filter(s => s)
                                            .join("\n");
                        }

                        return output;
                    }
                }
            
                #createProxy(keyName, { reduceValues = false } = {}) {
                    const outerThis = this;

                    return new Proxy({}, {
                        get(_, key) {
                            const values = outerThis.list.map(({ [keyName]: object }) => object[key]);
                            let returnValue;

                            if (reduceValues) {
                                if (values.every(value => value === values[0])) return values[0];
                            }
                            else {
                                return values;
                            }
                        },
                        set(_, key, value) {
                            outerThis.list.forEach(({ [keyName]: object }) => {
                                object[key] = value;
                            });

                            return true;
                        },

                        ownKeys() {
                            return [...new Set(outerThis.list.map(({ [keyName]: object }) => Object.keys(object)).flat())];
                        },
                        has(_, key) {
                            return this.ownKeys().includes(key);
                        },
                        getOwnPropertyDescriptor(_, key) {
                            if (this.ownKeys().includes(key)) {
                                return {
                                    configurable: true,
                                    enumerable: true,
                                    value: this.get(key),
                                    writable: true
                                }
                            }
                        },
                    });
                }
            };

            constructor() {
                this.#elem.append(
                    createElement("div", { class: "align-center" },
                        createElement("h2", null, "結果"),
                        this.#spinner,
                        createElement("div", { class: "align-center", style: { marginLeft: "auto", gap: "8px" } },
                            this.#sorter.button,
                            createElement("button", {
                                class: "icon",
                                title: "ファイルの読み込み",
                                innerHTML: '<svg width="15" height="15" viewbox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.2"><path d="M 5 1 v 8 M 1 5 h 8"/></svg>',
                                onclick: async () => {
                                    try {
                                        const fileHandles = await showOpenFilePicker({
                                            types: [
                                                {
                                                    description: "JSON ファイル",
                                                    accept: { "application/json": [".json"] },
                                                },
                                                {
                                                    description: "その他のテキストファイル",
                                                    accept: { "*/*": [".csv", ".dat", ".txt"], },
                                                },
                                            ],
                                            excludeAcceptAllOption: true,
                                            multiple: true,
                                        });

                                        for (const fileHandle of fileHandles) {
                                            const file = await fileHandle.getFile();
                                            const text = await file.text();
                                            const filename = file.name;
                                            const ext = filename.split(".").at(-1).toLowerCase();

                                            if (ext === "json") {
                                                this.#loadJSON(filename, text);
                                            }
                                            else {
                                                const lastModified = file.lastModified / 1000;
                                                this.#loadText(filename, lastModified, text);
                                            }
                                        }
                                    }
                                    catch (error) {
                                        if (!(error instanceof DOMException)) throw error;
                                    }
                                },
                            }),
                        )
                    ),
                    this.#listElem,
                    createElement("div", { style: { marginTop: "4px" } },
                        this.#saver.buttons,
                    ),
                );
                $("body").append(
                    this.#dragLine,
                    this.#dragImage,
                    this.#namelist,
                );

                ondrop = async e => {
                    if (!e.dataTransfer.items.length) return;
                    e.preventDefault();

                    const files = [];
                    const searchFile = async entry => {
                        if (entry.isFile) {
                            const file = await new Promise(resolve => entry.file(resolve));
                            files.push(file);
                        }
                        else if (entry.isDirectory) {
                            const dirReader = entry.createReader();
                            const allEntries = [];
                            while (true) {
                                const entries = await new Promise(resolve => dirReader.readEntries(resolve));
                                if (entries.length) allEntries.push(...entries);
                                else break;
                            }
                            
                            for (const entry of allEntries) {
                                await searchFile(entry);
                            }
                        }
                    };

                    const entries = [...e.dataTransfer.items].map(
                        item => (item.webkitGetAsEntry ?? item.getAsEntry).call(item)
                    ).filter(entry => entry);
                    for (const entry of entries) {
                        await searchFile(entry);
                    }

                    this.#spinner.hidden = false;
                    for (const file of files) {
                        if (file.name.split(".").at(-1).toLowerCase() === "json") {
                            this.#loadJSON(file.name, await file.text());
                        }
                    }
                    this.#spinner.hidden = true;
                };
                ondragover = e => {
                    if (!e.dataTransfer.items.length) return;
                    e.preventDefault();

                    e.dataTransfer.dropEffect = "copy";
                };

                addEventListener("keydown", e => {
                    if ((isMac ? e.metaKey : e.ctrlKey) && e.key === "s") {
                        e.preventDefault();

                        this.#saver.exec();
                    }
                });
            }

            get selected() {
                return this.#selected;
            }

            set selected(selected) {
                this.#selected = selected;

                this.#list.forEach(result => {
                    if (selected.includes(result)) result.elem.classList.add("selected");
                    else result.elem.classList.remove("selected");
                });
                if (selected.length) selected.at(-1).elem.focus();

                plot.targets = selected;
            }

            get saved() {
                return this.#list.every(result => result.saved)
            }

            append(...entries) {
                this.#listElem.append(...entries.map(({ elem }) => elem));
            
                this.#list = [
                    ...this.#list.filter(result => !entries.includes(result)),
                    ...entries,
                ];

                this.#namelist.update();
            }

            remove(...targets) {
                const indexed = targets.map(result => {
                    if (result.group) return [result.group.list.indexOf(result), result];
                    else return [this.#list.indexOf(result), result];
                });

                const action = {
                    undo: () => {
                        for (const [index, result] of indexed) {
                            if (result.group) result.group.insert(index, result);
                            else this.#insert(index, result);
                        }
                        
                        this.selected = targets;
                    },
                    redo: () => {
                        for (const result of targets) {
                            if (result.group) result.group.remove(result);
                            else this.#remove(...targets);
                        }
                    },
                };

                const log = createElement("div", {
                    class: "align-center",
                    style: { width: "100%", justifyContent: "space-between" },
                },
                    `${targets.length === 1 ? targets[0].displayName : `${targets.length}個の項目`}を削除しました`,
                    createElement("div", {
                        class: "clickable",
                        style: {
                            marginLeft: "20px",

                            borderRadius: "4px",
                            fontWeight: "bold",
                            padding: "0 2px",
                        },
                        onclick: () => {
                            undoManager.undo(action);
                            log.parentElement.remove();
                        },
                    }, "元に戻す"),
                );
                logger.log(log);

                undoManager.addAction(action);
                action.redo();
            }

            #insert(index, ...entries) {
                if (index < 0 || index >= this.#list.length) {
                    this.append(...entries);
                    return;
                }

                this.#list[index].elem.before(...entries.map(({ elem }) => elem));

                this.#list = [
                    ...this.#list.slice(0, index).filter(result => !entries.includes(result)),
                    ...entries,
                    ...this.#list.slice(index).filter(result => !entries.includes(result)),
                ];
            }

            #insertBefore(result, ...entries) {
                this.#insert(this.#list.indexOf(result), ...entries);
            }

            #insertAfter(result, ...entries) {
                this.#insert(this.#list.indexOf(result) + 1, ...entries);
            }

            #remove(...entries) {
                if (this.selected.some(result => entries.includes(result))) {
                    const selected = this.selected.filter(result => !entries.includes(result));

                    this.selected = (
                        selected.length ? selected
                        : entries.length < this.#list.length ? [
                            this.#list.slice(this.#list.indexOf(entries.slice(-1)[0]))
                                    .find(result => !entries.includes(result))
                            ?? this.#list.slice(0, this.#list.indexOf(entries.slice(-1)[0]))
                                    .findLast(result => !entries.includes(result))
                        ] : []
                    );
                }
                
                entries.map(({ elem }) => elem.remove());
                
                this.#list = this.#list.filter(result => !entries.includes(result));

                this.#namelist.update();
            }

            #loadJSON(filename, text) {
                const json = JSON.parse(text);

                // 旧バージョン用
                if (!json.data) {
                    const { Ibias, V, I, Ic1, Ic2 } = json;
                    json.data = { Ibias, V, I, Ic1, Ic2 };
                    json.Ibias = undefined;
                    json.V = undefined;
                    json.I = undefined;
                    json.Ic1 = undefined;
                    json.Ic2 = undefined;
                }
                if (typeof json.data.Ibias === "object") {
                    json.data = json.data.Ibias.map((_, i) => {
                        const data = json.data;
                        return {
                            Ibias: data.Ibias[i],
                            V: data.V[i],
                            I: data.I[i],
                            Ic1: data.Ic1[i],
                            Ic2: data.Ic2[i],
                        };
                    });
                }
                if (!json.calcparams && !json.fitparams && json.params) {
                    json.fitparams = {
                        Voffset: json.params.Voffset,
                        Ioffset: json.params.Ioffset,
                        V_Ic: json.params.V_Ic,
                        Vn: json.params.Vn,
                        Vsg: json.params.Vsg,
                    };

                    for (const key of ["Voffset", "Ioffset", "V_Ic", "Vn", "Vsg"]) {
                        if (key in json.params) delete json.params[key];
                    }
                }
                if (Array.isArray(json.data)) {
                    json.list = json.data.map(data => ({
                        name: json.name,
                        timestamp: round(new Date(json.date) / 1000),
                        data,
                        params: {...json.params},
                        fitparams: {...json.fitparams},
                    }));
                }
                if (json.date) {
                    json.timestamp = round(new Date(json.date) / 1000);
                    delete json.date;
                }
                if (json.list) {
                    json.list.forEach(result => {
                        result.timestamp ??= round(new Date(result.date) / 1000);
                        if (json.params) result.params ??= {...json.params};
                        if (json.calcparams) result.calcparams ??= {...json.calcparams};
                    });
                }
                (json.list ?? [json]).forEach(result => {
                    if (result.fitparams) {
                        result.calcparams = result.fitparams;
                        result.fitparams = undefined;
                    }

                    if (result.params.channel_assign) {
                        if (result.params.channel_assign === "Ch1=I, Ch2=V") {
                            result.params.channel_I = "Ch1";
                            result.params.channel_V = "Ch2";
                        }
                        else if (result.params.channel_assign === "Ch1=V, Ch2=I") {
                            result.params.channel_I = "Ch2";
                            result.params.channel_V = "Ch1";
                        }
                        else if (result.params.channel_assign === "Ch1-Ch2=I, Ch3=V") {
                            result.params.channel_I = "Ch1-Ch2";
                            result.params.channel_V = "Ch3";
                        }

                        delete result.params.channel_assign;
                    }
                });

                if (json.list) {
                    const resultGroup = new this.ResultGroup({
                        filename,
                        ...json,
                    });
                    resultGroup.saved = true;

                    this.append(resultGroup);
                    this.selected = [resultGroup];
                }
                else {
                    const result = new this.Result({
                        filename,
                        ...json,
                    });
                    result.saved = true;

                    this.append(result);
                    this.selected = [result];
                }
            }

            #loadText(filename, lastModified, text) {
                const V = [];
                const I = [];
                const lines = text.split("\n").filter(line => line.match(/,|\t/));

                lines.forEach(line => {
                    const [v, i] = line.split(/,|\t/).slice(0, 2).map(Number);

                    if ([v, i].every(Number.isFinite)) {
                        V.push(v);
                        I.push(i);
                    }
                });
                if (!V.length && !I.length) return;

                const result = new this.Result({
                    filename,
                    timestamp: lastModified,
                    data: { V, I },
                });
                result.saved = true;

                this.append(result);
                this.selected = [result];
            }
        }();

        const plot = new class {
            #elem = $("#plot");
            #targets = [];
            #data = [];
            #layout = {
                dragmode: "pan",
                font: {},
                grid: {
                    pattern: "independent",
                    xgap: 0.2,
                    ygap: 0.28,
                },
                legend: {
                    xanchor: "center",
                    yanchor: "middle",
                    x: 0.5,
                    y: 1.06,
                    orientation: "h",
                },
                xaxis: {
                    minor: {},
                    zeroline: false,
                },
                yaxis: {
                    automargin: false,
                    minor: {},
                    zeroline: false,
                },
                coloraxis: {
                    colorbar: {
                        outlinewidth: 0,
                        title: { side: "right" },
                        ypad: 0,
                    },
                },
                colorscale: {
                    diverging: [[0, "rgb(5,10,172)"], [0.35, "rgb(106,137,247)"], [0.5, "rgb(190,190,190)"], [0.6, "rgb(220,170,132)"], [0.7, "rgb(230,145,90)"], [1, "rgb(178,10,28)"]],
                    sequential: [[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],
                },
            };
            #layout3d = {
                font: {},
                margin: { l: 0, r: 0, t: 0, b: 0 },
                scene: {
                    aspectmode: "manual",
                    aspectratio: { x: 1, y: 1, z: 1 },
                    camera: { eye: { x: 1.25, y: -1.25, z: 1.25 } },
                    xaxis: {
                        minor: {},
                        title: {},
                        zeroline: false,
                    },
                    yaxis: {
                        minor: {},
                        title: {},
                        zeroline: false,
                    },
                    zaxis: {
                        minor: {},
                        title: {},
                        zeroline: false,
                    },
                },
                coloraxis: {
                    colorbar: {
                        outlinewidth: 0,
                        title: { side: "right" },
                        xpad: 25,
                        ypad: 50,
                    },
                },
                colorscale: {
                    diverging: [[0, "rgb(5,10,172)"], [0.35, "rgb(106,137,247)"], [0.5, "rgb(190,190,190)"], [0.6, "rgb(220,170,132)"], [0.7, "rgb(230,145,90)"], [1, "rgb(178,10,28)"]],
                    sequential: [[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],
                },
            };
            #config = {
                showTips: false,
                responsive: true,
                scrollZoom: true,
                displaylogo: false,
                modeBarButtonsToRemove: [
                    "toImage", "select2d", "lasso2d", "zoomIn2d", "zoomOut2d", "autoScale2d", "resetCameraDefault3d",
                ],
                modeBarButtonsToAdd: [
                    "drawline",
                    // "eraseshape",
                    {
                        name: "Save as Image",
                        icon: Plotly.Icons.camera,
                        group: 0,
                        click: () => {
                            this.#saveAsImage();
                        },
                    },
                    {
                        name: "Markers and Lines",
                        icon: {
                            width: 100,
                            height: 100,
                            path: "M 10 72.5 l 24 -38.4 l 30 20 l 26 -41.6 v 15 l -24 38.4 l -30 -20 l -26 41.6 M 10 80 m 0 -10 a 10 10 0 1 1 -0.01 0 M 35 40 m 0 -10 a 10 10 0 1 1 -0.01 0 M 65 60 m 0 -10 a 10 10 0 1 1 -0.01 0 M 90 20 m 0 -10 a 10 10 0 1 1 -0.01 0",
                        },
                        click: gd => {
                            this.#settings.fromObject({ tracemode: "lines+markers" });

                            this.updateData();
                        },
                    },
                    {
                        name: "Markers",
                        icon: {
                            "width": 100,
                            "height": 100,
                            "path": "M 10 80 m 0 -10 a 10 10 0 1 1 -0.01 0 M 35 40 m 0 -10 a 10 10 0 1 1 -0.01 0 M 65 60 m 0 -10 a 10 10 0 1 1 -0.01 0 M 90 20 m 0 -10 a 10 10 0 1 1 -0.01 0",
                        },
                        click: gd => {
                            this.#settings.fromObject({ tracemode: "markers" });
                            
                            this.updateData();
                        },
                    },
                    {
                        name: "Lines",
                        icon: {
                            "width": 100,
                            "height": 100,
                            "path": "M 10 72.5 l 24 -38.4 l 30 20 l 26 -41.6 v 15 l -24 38.4 l -30 -20 l -26 41.6",
                        },
                        click: gd => {
                            this.#settings.fromObject({ tracemode: "lines" });
                            
                            this.updateData();
                        },
                    },
                    {
                        name: "Toggle X Logscale",
                        icon: {
                            "width": 100,
                            "height": 100,
                            "path": "M 10 10 v 80 h 5 v -80 z M 50 10 v 80 h 5 v -80 z M 70 10 v 80 h 5 v -80 z M 80 10 v 80 h 5 v -80 z",
                        },
                        graphtype: ["xy", "xy + color"],
                        click: gd => {
                            const value = this.#options.logscale;

                            this.#settings.fromObject({
                                logscale: value.includes("X") ? value.replace("X", "") : "X" + value,
                            });

                            this.updateLayout();
                        },
                    },
                    {
                        name: "Toggle Y Logscale",
                        icon: {
                            "width": 100,
                            "height": 100,
                            "path": "M 10 10 h 80 v 5 h -80 z M 10 20 h 80 v 5 h -80 z M 10 40 h 80 v 5 h -80 z M 10 80 h 80 v 5 h -80 z",
                        },
                        graphtype: ["xy", "xy + color"],
                        click: gd => {
                            const value = this.#options.logscale;

                            this.#settings.fromObject({
                                logscale: value.includes("Y") ? value.replace("Y", "") : value + "Y",
                            });

                            this.updateLayout();
                        },
                    },
                    {
                        name: "Toggle X Logscale 3D",
                        icon: {
                            "width": 100,
                            "height": 100,
                            "path": "M 10 65 v 10 l 32.5 -65 h -5 z M 37.5 90 h 5 l 40 -80 h -5 z M 57.5 90 h 5 l 27.5 -55 v -10 z M 67.5 90 h 5 l 17.5 -35 v -10 z",
                        },
                        graphtype: ["xyz", "xyz + color"],
                        click: gd => {
                            const value = this.#options.logscale3d;

                            this.#settings.fromObject({
                                logscale3d: value.includes("X") ? value.replace("X", "") : Array.from("X" + value).sort().join(""),
                            });

                            this.updateLayout();
                        },
                    },
                    {
                        name: "Toggle Y Logscale 3D",
                        icon: {
                            "width": 100,
                            "height": 100,
                            "path": "M 10 35 v -10 l 32.5 65 h -5 z M 37.5 10 h 5 l 40 80 h -5 z M 57.5 10 h 5 l 27.5 55 v 10 z M 67.5 10 h 5 l 17.5 35 v 10 z",
                        },
                        graphtype: ["xyz", "xyz + color"],
                        click: gd => {
                            const value = this.#options.logscale3d;

                            this.#settings.fromObject({
                                logscale3d: value.includes("Y") ? value.replace("Y", "") : Array.from("Y" + value).sort().join(""),
                            });

                            this.updateLayout();
                        },
                    },
                    {
                        name: "Toggle Z Logscale 3D",
                        icon: {
                            "width": 100,
                            "height": 100,
                            "path": "M 10 10 h 80 v 5 h -80 z M 10 20 h 80 v 5 h -80 z M 10 40 h 80 v 5 h -80 z M 10 80 h 80 v 5 h -80 z",
                        },
                        graphtype: ["xyz", "xyz + color"],
                        click: gd => {
                            const value = this.#options.logscale3d;

                            this.#settings.fromObject({
                                logscale3d: value.includes("Z") ? value.replace("Z", "") : Array.from("Z" + value).sort().join(""),
                            });

                            this.updateLayout();
                        },
                    },
                    {
                        name: "More Settings...",
                        icon: {
                            "width": 100,
                            "height": 100,
                            "path": "M 20 50 m 0 -10 a 10 10 0 1 1 -0.01 0 M 50 50 m 0 -10 a 10 10 0 1 1 -0.01 0 M 80 50 m 0 -10 a 10 10 0 1 1 -0.01 0",
                        },
                        click: (gd, e) => {
                            const { right } = this.#elem.getBoundingClientRect();
                            const { bottom } = e.target.closest("a.modebar-btn").getBoundingClientRect();
                            
                            this.#settings.open({
                                x: right, y: bottom,
                                xanchor: "right", yanchor: "top",
                                xmargin: 4,
                            });
                        },
                    },
                    {
                        name: "Toggle Fullscreen",
                        icon: {
                            "width": 10,
                            "height": 10,
                            "path": "M 1 1 v 3 h 1 v -2 h 2 v -1 z M 9 1 v 3 h -1 v -2 h -2 v -1 z M 9 9 v -3 h -1 v 2 h -2 v 1 z M 1 9 v -3 h 1 v 2 h 2 v 1 z",
                        },
                        click: gd => {
                            if (document.fullscreenElement) document.exitFullscreen();
                            else this.#elem.requestFullscreen();
                        },
                    },
                ],
            };
            #options = {
                subplots: false,
                fitplot: true,
                graphtype: "xy",
            };
            #settings = new class {
                #outerThis;
                #menu = new Popup({ style: { width: "250px", maxHeight: "90vh", overflowY: "auto", padding: "6px 8px" } });
                #forms = {
                    // プロット
                    tracemode: new NamedForm({
                        lname: "タイプ",
                        type: "select",
                        values: {
                            "点+線": "lines+markers",
                            "点": "markers",
                            "線": "lines",
                        },
                        defaultValue: "lines+markers",
                        onchange: () => {
                            this.#update();
                            plot.updateData();
                        },
                    }),
                    tracetype: new NamedForm({
                        lname: "描画",
                        type: "select",
                        values: {
                            "WebGL": "scattergl",
                            "SVG": "scatter",
                        },
                        defaultValue: "scattergl",
                        onchange: () => {
                            this.#update();
                            plot.updateData();
                        },
                    }),
                    markersize: new NamedForm({
                        lname: "サイズ",
                        type: "number",
                        step: 0.5,
                        min: 0.5,
                        defaultValue: 6,
                        onchange: () => {
                            this.#update();
                            plot.updateData();
                        },
                    }),
                    linewidth: new NamedForm({
                        lname: "線幅",
                        type: "number",
                        step: 0.5,
                        min: 0.5,
                        defaultValue: 2,
                        onchange: () => {
                            this.#update();
                            plot.updateData();
                        },
                    }),
                    colorway: new NamedForm({
                        lname: "色",
                        type: "select",
                        values: {
                            "デフォルト": null,
                            "黒": ["#000000"],
                            "白": ["#f2f5fa"],
                            "Origin": [
                                "#000000",
                                "#0000FF",
                                "#FF0000",
                                "#00FF00",
                                "#00FFFF",
                                "#FF00FF",
                                "#FFFF00",
                                "#808000",
                                "#000080",
                                "#800080",
                                "#800000",
                                "#008000",
                                "#008080",
                            ],
                            "Alphabet": [
                                "#AA0DFE",
                                "#3283FE",
                                "#85660D",
                                "#782AB6",
                                "#565656",
                                "#1C8356",
                                "#16FF32",
                                "#F7E1A0",
                                "#E2E2E2",
                                "#1CBE4F",
                                "#C4451C",
                                "#DEA0FD",
                                "#FE00FA",
                                "#325A9B",
                                "#FEAF16",
                                "#F8A19F",
                                "#90AD1C",
                                "#F6222E",
                                "#1CFFCE",
                                "#2ED9FF",
                                "#B10DA1",
                                "#C075A6",
                                "#FC1CBF",
                                "#B00068",
                                "#FBE426",
                                "#FA0087"
                            ],
                            "Antique": [
                                "rgb(133, 92, 117)",
                                "rgb(217, 175, 107)",
                                "rgb(175, 100, 88)",
                                "rgb(115, 111, 76)",
                                "rgb(82, 106, 131)",
                                "rgb(98, 83, 119)",
                                "rgb(104, 133, 92)",
                                "rgb(156, 156, 94)",
                                "rgb(160, 97, 119)",
                                "rgb(140, 120, 93)",
                                "rgb(124, 124, 124)"
                            ],
                            "Bold": [
                                "rgb(127, 60, 141)",
                                "rgb(17, 165, 121)",
                                "rgb(57, 105, 172)",
                                "rgb(242, 183, 1)",
                                "rgb(231, 63, 116)",
                                "rgb(128, 186, 90)",
                                "rgb(230, 131, 16)",
                                "rgb(0, 134, 149)",
                                "rgb(207, 28, 144)",
                                "rgb(249, 123, 114)",
                                "rgb(165, 170, 153)"
                            ],
                            "D3": [
                                "#1F77B4",
                                "#FF7F0E",
                                "#2CA02C",
                                "#D62728",
                                "#9467BD",
                                "#8C564B",
                                "#E377C2",
                                "#7F7F7F",
                                "#BCBD22",
                                "#17BECF"
                            ],
                            "Dark2": [
                                "rgb(27,158,119)",
                                "rgb(217,95,2)",
                                "rgb(117,112,179)",
                                "rgb(231,41,138)",
                                "rgb(102,166,30)",
                                "rgb(230,171,2)",
                                "rgb(166,118,29)",
                                "rgb(102,102,102)"
                            ],
                            "Dark24": [
                                "#2E91E5",
                                "#E15F99",
                                "#1CA71C",
                                "#FB0D0D",
                                "#DA16FF",
                                "#222A2A",
                                "#B68100",
                                "#750D86",
                                "#EB663B",
                                "#511CFB",
                                "#00A08B",
                                "#FB00D1",
                                "#FC0080",
                                "#B2828D",
                                "#6C7C32",
                                "#778AAE",
                                "#862A16",
                                "#A777F1",
                                "#620042",
                                "#1616A7",
                                "#DA60CA",
                                "#6C4516",
                                "#0D2A63",
                                "#AF0038"
                            ],
                            "G10": [
                                "#3366CC",
                                "#DC3912",
                                "#FF9900",
                                "#109618",
                                "#990099",
                                "#0099C6",
                                "#DD4477",
                                "#66AA00",
                                "#B82E2E",
                                "#316395"
                            ],
                            "Light24": [
                                "#FD3216",
                                "#00FE35",
                                "#6A76FC",
                                "#FED4C4",
                                "#FE00CE",
                                "#0DF9FF",
                                "#F6F926",
                                "#FF9616",
                                "#479B55",
                                "#EEA6FB",
                                "#DC587D",
                                "#D626FF",
                                "#6E899C",
                                "#00B5F7",
                                "#B68E00",
                                "#C9FBE5",
                                "#FF0092",
                                "#22FFA7",
                                "#E3EE9E",
                                "#86CE00",
                                "#BC7196",
                                "#7E7DCD",
                                "#FC6955",
                                "#E48F72"
                            ],
                            "Pastel": [
                                "rgb(102, 197, 204)",
                                "rgb(246, 207, 113)",
                                "rgb(248, 156, 116)",
                                "rgb(220, 176, 242)",
                                "rgb(135, 197, 95)",
                                "rgb(158, 185, 243)",
                                "rgb(254, 136, 177)",
                                "rgb(201, 219, 116)",
                                "rgb(139, 224, 164)",
                                "rgb(180, 151, 231)",
                                "rgb(179, 179, 179)"
                            ],
                            "Pastel1": [
                                "rgb(251,180,174)",
                                "rgb(179,205,227)",
                                "rgb(204,235,197)",
                                "rgb(222,203,228)",
                                "rgb(254,217,166)",
                                "rgb(255,255,204)",
                                "rgb(229,216,189)",
                                "rgb(253,218,236)",
                                "rgb(242,242,242)"
                            ],
                            "Pastel2": [
                                "rgb(179,226,205)",
                                "rgb(253,205,172)",
                                "rgb(203,213,232)",
                                "rgb(244,202,228)",
                                "rgb(230,245,201)",
                                "rgb(255,242,174)",
                                "rgb(241,226,204)",
                                "rgb(204,204,204)"
                            ],
                            "Plotly": [
                                "#636EFA",
                                "#EF553B",
                                "#00CC96",
                                "#AB63FA",
                                "#FFA15A",
                                "#19D3F3",
                                "#FF6692",
                                "#B6E880",
                                "#FF97FF",
                                "#FECB52"
                            ],
                            "Prism": [
                                "rgb(95, 70, 144)",
                                "rgb(29, 105, 150)",
                                "rgb(56, 166, 165)",
                                "rgb(15, 133, 84)",
                                "rgb(115, 175, 72)",
                                "rgb(237, 173, 8)",
                                "rgb(225, 124, 5)",
                                "rgb(204, 80, 62)",
                                "rgb(148, 52, 110)",
                                "rgb(111, 64, 112)",
                                "rgb(102, 102, 102)"
                            ],
                            "Safe": [
                                "rgb(136, 204, 238)",
                                "rgb(204, 102, 119)",
                                "rgb(221, 204, 119)",
                                "rgb(17, 119, 51)",
                                "rgb(51, 34, 136)",
                                "rgb(170, 68, 153)",
                                "rgb(68, 170, 153)",
                                "rgb(153, 153, 51)",
                                "rgb(136, 34, 85)",
                                "rgb(102, 17, 0)",
                                "rgb(136, 136, 136)"
                            ],
                            "Set1": [
                                "rgb(228,26,28)",
                                "rgb(55,126,184)",
                                "rgb(77,175,74)",
                                "rgb(152,78,163)",
                                "rgb(255,127,0)",
                                "rgb(255,255,51)",
                                "rgb(166,86,40)",
                                "rgb(247,129,191)",
                                "rgb(153,153,153)"
                            ],
                            "Set2": [
                                "rgb(102,194,165)",
                                "rgb(252,141,98)",
                                "rgb(141,160,203)",
                                "rgb(231,138,195)",
                                "rgb(166,216,84)",
                                "rgb(255,217,47)",
                                "rgb(229,196,148)",
                                "rgb(179,179,179)"
                            ],
                            "Set3": [
                                "rgb(141,211,199)",
                                "rgb(255,255,179)",
                                "rgb(190,186,218)",
                                "rgb(251,128,114)",
                                "rgb(128,177,211)",
                                "rgb(253,180,98)",
                                "rgb(179,222,105)",
                                "rgb(252,205,229)",
                                "rgb(217,217,217)",
                                "rgb(188,128,189)",
                                "rgb(204,235,197)",
                                "rgb(255,237,111)"
                            ],
                            "T10": [
                                "#4C78A8",
                                "#F58518",
                                "#E45756",
                                "#72B7B2",
                                "#54A24B",
                                "#EECA3B",
                                "#B279A2",
                                "#FF9DA6",
                                "#9D755D",
                                "#BAB0AC"
                            ],
                            "Vivid": [
                                "rgb(229, 134, 6)",
                                "rgb(93, 105, 177)",
                                "rgb(82, 188, 163)",
                                "rgb(153, 201, 69)",
                                "rgb(204, 97, 176)",
                                "rgb(36, 121, 108)",
                                "rgb(218, 165, 27)",
                                "rgb(47, 138, 196)",
                                "rgb(118, 78, 159)",
                                "rgb(237, 100, 90)",
                                "rgb(165, 170, 153)"
                            ]
                        },
                        defaultValue: null,
                        onchange: () => {
                            this.#update();
                            plot.update();
                        },
                    }),
                    
                    // グラフ
                    showtitle: new NamedForm({
                        lname: "タイトル",
                        type: "select",
                        values: {
                            "非表示": false,
                            "表示": true,
                        },
                        defaultValue: true,
                        onchange: () => {
                            this.#update();
                            plot.update();
                        },
                    }),
                    legend: new NamedForm({
                        lname: "凡例",
                        type: "select",
                        values: {
                            "非表示": null,
                            "左上": "lefttop",
                            "右上": "righttop",
                            "左下": "leftbottom",
                            "右下": "rightbottom",
                        },
                        defaultValue: null,
                        onchange: () => {
                            this.#update();
                            plot.update();
                        },
                    }),
                    logscale: new NamedForm({
                        lname: "対数軸",
                        type: "select",
                        values: {
                            "オフ": "",
                            "X軸のみ": "X",
                            "Y軸のみ": "Y",
                            "X軸+Y軸": "XY",
                        },
                        defaultValue: "",
                        onchange: () => this.#onchange(),
                    }),
                    logscale3d: new NamedForm({
                        lname: "対数軸",
                        type: "select",
                        values: {
                            "オフ": "",
                            "X軸のみ": "X",
                            "Y軸のみ": "Y",
                            "Z軸のみ": "Z",
                            "X軸+Y軸": "XY",
                            "X軸+Z軸": "XZ",
                            "Y軸+Z軸": "YZ",
                            "X軸+Y軸+Z軸": "XYZ",
                        },
                        defaultValue: "",
                        onchange: () => this.#onchange(),
                    }),
                    frame: new NamedForm({
                        lname: "外枠",
                        type: "select",
                        values: {
                            "なし": false,
                            "下+左": true,
                            "下+左+上+右": "all",
                        },
                        defaultValue: "all",
                        onchange: () => this.#onchange(),
                    }),
                    ticks: new NamedForm({
                        lname: "目盛り",
                        type: "select",
                        values: {
                            "なし": false,
                            "主目盛りのみ": true,
                            "主目盛り+副目盛り": "all",
                        },
                        defaultValue: "all",
                        onchange: () => this.#onchange(),
                    }),
                    grid: new NamedForm({
                        lname: "グリッド",
                        type: "select",
                        values: {
                            "なし": false,
                            "自動": "auto",
                            "主目盛りのみ": true,
                            "主目盛り+副目盛り": "all",
                        },
                        defaultValue: "auto",
                        onchange: () => this.#onchange(),
                    }),
                    darkmode: new NamedForm({
                        lname: "テーマ",
                        type: "select",
                        values: {
                            "自動": null,
                            "ライト": false,
                            "ダーク": true,
                        },
                        defaultValue: null,
                        onchange: () => {
                            this.#update();
                            plot.update();
                        },
                    }),
                    
                    // 文字
                    fontsize: new NamedForm({
                        lname: "サイズ",
                        type: "number",
                        step: 0.5,
                        min: 0.5,
                        defaultValue: 16,
                        onchange: () => {
                            this.#update();

                            const value = this.#forms.fontsize.value;
                            for (const annotation of plot.#layout.annotations) {
                                const { x, y } = annotation;

                                if (x > 1 || y > 1) annotation.font.size = value * 1.2;
                            }
                            plot.updateLayout();
                        },
                    }),
                    fontfamily: new NamedForm({
                        lname: "フォント",
                        type: "select",
                        values: {
                            "デフォルト": null,
                            "Arial": "Arial",
                            "Times New Roman": "Times New Roman",
                        },
                        defaultValue: "Times New Roman",
                        onchange: () => this.#onchange(),
                    }),
                    
                    // 保存・コピー
                    figsize: new NamedForm({
                        lname: "サイズ",
                        type: "select",
                        values: [
                            "4×3",
                            "6.4×4.8",
                            "8×6",
                            "12×9",
                            "16×12",
                            "32×24",
                            "64×48",
                            "19.2×10.8",
                            "38.4×21.6",
                            "表示サイズ",
                        ],
                        defaultValue: "6.4×4.8",
                    }),
                    dpi: new NamedForm({
                        lname: "dpi",
                        type: "select",
                        values: [
                            50,
                            75,
                            100,
                            150,
                            200,
                            300,
                            400,
                            500,
                            1000,
                        ],
                        defaultValue: 200,
                    }),
                };
                
                constructor(outerThis) {
                    this.#outerThis = outerThis;

                    const {
                        tracemode, tracetype, markersize, linewidth, colorway,
                        showtitle, legend, logscale, logscale3d, frame, ticks, grid, darkmode,
                        fontsize, fontfamily,
                        figsize, dpi } = this.#forms;

                    this.#menu.elem.append(
                        createElement("h3", null, "プロット"),
                        tracemode.elem,
                        tracetype.elem,
                        markersize.elem,
                        linewidth.elem,
                        colorway.elem,

                        createElement("h3", { style: { marginTop: "0.25em" } }, "グラフ"),
                        showtitle.elem,
                        legend.elem,
                        logscale.elem,
                        logscale3d.elem,
                        frame.elem,
                        ticks.elem,
                        grid.elem,
                        darkmode.elem,

                        createElement("h3", { style: { marginTop: "0.25em" } }, "文字"),
                        fontsize.elem,
                        fontfamily.elem,
                        
                        createElement("h3", { style: { marginTop: "0.25em" } }, "保存・コピー"),
                        figsize.elem,
                        dpi.elem,
                    );
                    
                    this.#update();
                }

                open(position) {
                    this.#menu.open(position);
                }

                toObject() {
                    return Object.fromEntries(Object.entries(this.#forms).map(([key, { value }]) => [key, value]));
                }

                fromObject(object) {
                    for (const key of Object.keys(this.#forms)) {
                        if (key in object) this.#forms[key].value = object[key];
                    }

                    this.#update()
                }

                onchangeGraphtype() {
                    const { logscale, logscale3d } = this.#forms;
                    const is3d = plot.#options.graphtype.startsWith("xyz");

                    logscale.elem.hidden = is3d;
                    logscale3d.elem.hidden = !is3d;
                }

                #update() {
                    if (!Object.values(this.#forms).every(({ isValid }) => isValid)) return;

                    Object.assign(this.#outerThis.#options, this.toObject());
                }

                #onchange() {
                    this.#update();
                    plot.updateLayout();
                }
            }(this);
            #controls = new class {
                #elem = $("#plotcontrols");
                #sliders = createElement("div");
                #subplots = new NamedForm({
                    lname: "個別のグラフにプロット",
                    type: "checkbox",
                    defaultValue: false,
                    props: { hidden: true },
                    onchange: () => {
                        plot.#options.subplots = this.#subplots.value;
                        plot.update();
                    },
                });
                #fitplot = new NamedForm({
                    lname: "フィット結果のプロット",
                    type: "checkbox",
                    defaultValue: true,
                    props: { hidden: true },
                    onchange: () => {
                        plot.#options.fitplot = this.#fitplot.value;
                        plot.updateData();
                    },
                });

                constructor() {
                    this.#elem.append(
                        this.#sliders,
                        this.#subplots.elem,
                        this.#fitplot.elem,
                    );
                }

                update() {
                    const { graphtype, subplots } = plot.#options;

                    while (this.#sliders.firstChild) this.#sliders.firstChild.remove();
                    if (
                        !graphtype.startsWith("xyz") && (
                            plot.#xaxis.group === plot.#Axis.group1
                            && plot.#yaxis.group === plot.#Axis.group1
                            && (!graphtype.includes("color") || plot.#caxis.group === plot.#Axis.group1)
                        )
                        || (
                            plot.#xaxis3d.group === plot.#Axis.group1
                            && plot.#yaxis3d.group === plot.#Axis.group1
                            && plot.#zaxis3d.group === plot.#Axis.group1
                            && (!graphtype.includes("color") || plot.#caxis3d.group === plot.#Axis.group1)
                        )
                    ) {
                        this.#sliders.append(...plot.targets.filter(result => result.slider).map(result => result.slider.elem));
                    }

                    this.#subplots.elem.hidden = plot.targets.length < 2;

                    const [xaxis, yaxis] = [plot.#xaxis.key, plot.#yaxis.key];
                    this.#fitplot.elem.hidden = !(
                        (plot.targets.length === 1 || subplots) && (
                            !graphtype.startsWith("xyz") && (
                                [plot.#xaxis.key, plot.#caxis.key].includes("V") && ["I", "dIdV"].includes(plot.#yaxis.key)
                                || plot.targets[0].fits && `${plot.#yaxis.key}-${plot.#xaxis.key}` in plot.targets[0].fits
                            )
                            || (
                                [plot.#xaxis3d.key, plot.#yaxis3d.key].includes("V") && ["I", "dIdV"].includes(plot.#zaxis3d.key)
                            )
                        )
                    );

                    this.#elem.classList.remove("overflow");
                    if (this.#elem.clientHeight < this.#elem.scrollHeight) this.#elem.classList.add("overflow");
                }
            }();
            #controls2 = new class {
                #elem = $("#plotcontrols2");
                #graphtypeSelector = new NamedForm({
                    type: "select",
                    values: ["xy", "xy + color", "xyz", "xyz + color"],
                    defaultValue: "xy",
                    props: { style: { width: "100px" } },
                    onchange: async () => {
                        plot.#options.graphtype = this.#graphtypeSelector.value;
                        
                        await plot.update();
                        plot.#updateModebar();
                        plot.#settings.onchangeGraphtype();
                    },
                });
                xtitle = createElement("div", { class: "clickable", style: { padding: "4px 8px" }, hidden: true });
                ytitle = createElement("div", { class: "clickable", style: { padding: "4px 8px" }, hidden: true });
                ztitle = createElement("div", { class: "clickable", style: { padding: "4px 8px" }, hidden: true });

                constructor() {
                    this.#elem.append(
                        this.xtitle,
                        this.ytitle,
                        this.ztitle,
                        this.#graphtypeSelector.elem,
                    );
                }

                set fixed(fixed) {
                    this.#elem.style.opacity = fixed ? "1" : "";
                }

                update() {
                    if (plot.#options.graphtype.startsWith("xyz")) {
                        for (const [elem, axisname, { name, unit }] of [
                            [this.xtitle, "x", plot.#xaxis3d],
                            [this.ytitle, "y", plot.#yaxis3d],
                            [this.ztitle, "z", plot.#zaxis3d],
                        ]) {
                            elem.hidden = false;
                            elem.innerHTML = `${axisname}: <b>${name}${unit && ` (${unit})`}</b>`;
                        }
                    }
                    else {
                        for (const elem of [this.xtitle, this.ytitle, this.ztitle]) {
                            elem.hidden = true;
                        }
                    }
                }
            }();
            #contextmenu = new Contextmenu(null,
                createElement("button", {
                    onclick: async () => {
                        this.#contextmenu.close();

                        await navigator.clipboard.write([
                            new ClipboardItem({ "image/png": await this.toImage("png") })
                        ]);

                        logger.log("PNGをコピーしました");
                    },
                }, "グラフをPNG形式でコピー"),
                createElement("button", {
                    onclick: async () => {
                        this.#contextmenu.close();

                        await navigator.clipboard.write([
                            new ClipboardItem({ "image/svg+xml": await this.toImage("svg") })
                        ]);

                        logger.log("SVGをコピーしました");
                    },
                }, "グラフをSVG形式でコピー"),
                createElement("button", {
                    onclick: async () => {
                        this.#contextmenu.close();

                        await navigator.clipboard.writeText(JSON.stringify(this));

                        logger.log("JSONをコピーしました");
                    },
                }, "グラフをJSON形式でコピー"),
                createElement("div", { class: "hline" }),
                createElement("button", {
                    onclick: async () => {
                        this.#contextmenu.close();

                        await navigator.clipboard.writeText(
                            plot.#data.map(
                                ({ x, y }) => x.map(
                                    (_, i) => [x[i], y[i]].map(
                                        value => Number.isFinite(value) ? value : ""
                                    ).join("\t")
                                ).join("\n")
                            ).join("\n\n")
                        );

                        logger.log("DATをコピーしました");
                    },
                }, "データをDAT形式でコピー"),
                createElement("button", {
                    onclick: async () => {
                        this.#contextmenu.close();

                        await navigator.clipboard.writeText(
                            plot.#data.map(
                                ({ x, y }) => x.map(
                                    (_, i) => [x[i], y[i]].map(
                                        value => Number.isFinite(value) ? value : ""
                                    ).join(",")
                                ).join("\n")
                            ).join("\n\n")
                        );

                        logger.log("CSVをコピーしました");
                    },
                }, "データをCSV形式でコピー"),
            );
            #Axis = class {
                static group1 = Object.keys(info.data).filter(key => info.data[key].plotgroup === 1);
                static group2 = Object.keys(info.data).filter(key => info.data[key].plotgroup === 2);
                static axes = [];
                group = this.constructor.group1;
                axisname;
                type;
                #key1;
                #key2;
                #selector = new Selectmenu({
                    autoclose: false,
                    props: { style: { maxHeight: "250px", overflowY: "auto" } },
                    onchange: () => {
                        this.#onchange();
                        plot.update();
                    },
                    update: () => {
                        const keys = [...this.constructor.group1, ...this.constructor.group2];

                        for (const i in keys) {
                            const key = keys[i];
                            const option = this.#selector.options[i];

                            option.inert = !(plot.targets.length && plot.targets.some(result => result.has(key)));
                        }
                    },
                });
                #contextmenu = new Contextmenu(null,
                    createElement("button", {
                        onclick: () => {
                            this.#contextmenu.close();

                            const old = this.customName || this.altname;
                            const customName = prompt("軸のタイトルを入力（未入力でリセット）", old).trim();

                            if (customName !== null && customName !== this.customName) {
                                this.customName = customName || undefined;
                                plot.updateData();
                            }
                        },
                    }, "軸名を編集..."),
                );
                #clickTargets = [];
                #customNames = {};
                customTitle = "";

                constructor({ axisname, default_, type = "2D" }) {
                    this.axisname = axisname;
                    this.type = type;
                    this.constructor.axes.push(this);

                    this.#selector.values = Object.fromEntries(
                        [...this.constructor.group1, ...this.constructor.group2].map(key => {
                            const { lname, selname, unit } = info.data[key];

                            return ["$" + (selname ?? lname) + (unit && `\\:(\\rm ${unit})`) + "$", key];
                        }),
                    );
                    for (const option of this.#selector.options) {
                        Object.assign(option.style, { height: "2em", flexShrink: "0" });
                    }
                    this.#selector.options[this.constructor.group1.length].before(
                        createElement("div", { class: "hline" }),
                    );

                    for (const key of ["name", "lname", "altname", "unit", "SIpow"]) {
                        Object.defineProperty(this, key, {
                            get: () => info.data[this.key]?.[key],
                        });
                    }

                    this.key = default_;
                }

                get key() {
                    if (this.group === this.constructor.group1) return this.#key1;
                    if (this.group === this.constructor.group2) return this.#key2;
                }

                set key(key) {
                    const { group1, group2 } = this.constructor;

                    if (group1.includes(key)) {
                        this.#key1 = key;
                        this.group = group1;
                    }
                    else if (group2.includes(key)) {
                        this.#key2 = key;
                        this.group = group2;
                    }

                    if (this.#selector.value !== key) this.#selector.value = key;
                }

                get customName() {
                    return this.#customNames[this.key];
                }

                set customName(customName) {
                    this.#customNames[this.key] = customName;
                }

                updateClickTarget() {
                    const { graphtype } = plot.#options;
                    this.#clickTargets.forEach(elem => elem.remove());
                    this.#clickTargets = [];

                    if (!graphtype.startsWith("xyz") && this.type === "2D") {
                        const targets = (
                            this.axisname === "c" ? $$(".cbtitle") : $$(`[class^="g-${this.axisname}"][class$="title"]`)
                        );
                        for (const target of targets) {
                            const { left, top, width, height } = target.getBoundingClientRect();

                            const clickTarget = createElement("div", {
                                class: "clickable",
                                style: {
                                    position: "absolute",
                                    borderRadius: "8px",
                                    left: `${left - 8}px`,
                                    top: `${top - 8}px`,
                                    width: `${width + 16}px`,
                                    height: `${height + 16}px`,
                                },
                                tabIndex: "0",
                                onclick: () => {
                                    this.#selector.update();

                                    const { left, right, top } = clickTarget.getBoundingClientRect();
                                    const pos = this.axisname === "x" ? {
                                        x: left,
                                        y: top,
                                        yanchor: "bottom",
                                        ymargin: 4,
                                    } : this.axisname === "y" ? {
                                        x: right,
                                        y: top,
                                        xmargin: 4,
                                    } : {
                                        x: left,
                                        y: top,
                                        xanchor: "right",
                                        xmargin: 4,
                                    };
                                    this.#selector.open(pos);
                                },
                                oncontextmenu: e => {
                                    this.#contextmenu.open(e);

                                    e.stopPropagation();
                                    return false;
                                },
                            });

                            this.#clickTargets.push(clickTarget);
                        }
                    }

                    else if (graphtype.startsWith("xyz") && this.type === "3D") {
                        const target = this.axisname === "c" ? $(".cbtitle") : plot.#controls2[this.axisname + "title"];
                        if (!target) return;

                        const { left, top, width, height } = target.getBoundingClientRect();
                        const padding = this.axisname === "c" ? 8 : 0;
                        const clickTarget = createElement("div", {
                            class: "clickable",
                            style: {
                                position: "absolute",
                                borderRadius: "8px",
                                left: `${left - padding}px`,
                                top: `${top - padding}px`,
                                width: `${width + 2 * padding}px`,
                                height: `${height + 2 * padding}px`,
                                zIndex: "2",
                            },
                            tabIndex: "0",
                            onclick: () => {
                                this.#selector.update();
                                plot.#controls2.fixed = true;
                                this.#selector.onclose = () => plot.#controls2.fixed = false;

                                const { left, top, bottom } = clickTarget.getBoundingClientRect();
                                const pos = this.axisname === "c" ? {
                                    x: left,
                                    y: top,
                                    xanchor: "right",
                                    xmargin: 4,
                                } : {
                                    x: left,
                                    y: top,
                                    yanchor: "bottom",
                                    ymargin: 4,
                                };
                                this.#selector.open(pos);
                            },
                            oncontextmenu: e => {
                                this.#contextmenu.open(e);

                                e.stopPropagation();
                                return false;
                            },
                        });

                        this.#clickTargets.push(clickTarget);
                    }

                    plot.#elem.append(...this.#clickTargets);
                }

                #onchange() {
                    const { axes, group1, group2 } = this.constructor;

                    const key = this.#selector.value;
                    const group = [group1, group2].find(group => group.includes(key));
                    const otherAxes = axes.filter(axis => axis !== this && axis.type === this.type );
                    const sameAxis = otherAxes.find(axis => axis.key === key);

                    if (sameAxis) {
                        sameAxis.key = this.key;
                    }
                    else if ([group, ...otherAxes.map(axis => axis.group)].filter(group => group === group1).length === 1) {
                        let changeAxis;
                        
                        this.group = group;
                        if (group === group1) {
                            changeAxis = otherAxes[0];
                            changeAxis.group = group1;
                        }
                        else {
                            changeAxis = otherAxes.find(axis => axis.group === group1);
                            changeAxis.group = group2;
                        }

                        if (key === changeAxis.key) changeAxis.key = this.key;
                        else if (changeAxis.key === undefined) {
                            const keys = [...group1, ...group2];

                            changeAxis.key = group.find(_key => (
                                _key !== "date"
                                && _key !== key
                                && _key !== otherAxes.find(axis => axis !== changeAxis).key
                                && !this.#selector.options[keys.indexOf(_key)].inert
                            ));
                        }
                        else changeAxis.key = changeAxis.key; // フォームの更新
                    }

                    this.key = key;
                }
            };
            #xaxis = new this.#Axis({ axisname: "x", default_: "V" });
            #yaxis = new this.#Axis({ axisname: "y", default_: "I" });
            #caxis = new this.#Axis({ axisname: "c", default_: "t" });
            #xaxis3d = new this.#Axis({ axisname: "x", type: "3D", default_: "V" });
            #yaxis3d = new this.#Axis({ axisname: "y", type: "3D", default_: "t" });
            #zaxis3d = new this.#Axis({ axisname: "z", type: "3D", default_: "I" });
            #caxis3d = new this.#Axis({ axisname: "c", type: "3D", default_: "T" });
            #Annotation = class {
                #selector = new Popup({ style: { padding: "8px" } });
                #contextmenu = new Contextmenu(null,
                    createElement("button", {
                        onclick: () => {
                            const { text } = this.#objects[this.#clickedIndex] ?? {};
                            navigator.clipboard.writeText(text.replaceAll(/^\$|\$$/g, ""));

                            logger.log("数式をコピーしました");

                            this.#contextmenu.close();
                        },
                    }, "数式をコピー"),
                    createElement("button", {
                        onclick: () => {
                            this.#contextmenu.close();

                            const old = this.#customText;
                            const customText = prompt("テキストを入力（未入力でリセット）", old).trim();

                            if (customText !== null && customText !== this.#customText) {
                                this.#customText = customText;
                                plot.updateData();
                            }
                        },
                    }, "テキストを編集..."),
                );
                #displayToggle = new NamedForm({
                    name: "表示",
                    lname: "表示".bold(),
                    type: "checkbox",
                    defaultValue: true,

                    onchange: () => {
                        for (const form of this.#forms) {
                            form.disabled = !this.#displayToggle.value;
                        }

                        plot.updateData();
                    }
                });
                #objects = [];
                #clickTargets = [];
                #clickedIndex = -1;
                #infoMap;
                #forms;
                #customText = "";
                
                constructor({ infoMap, selected = [], x, y, xanchor, yanchor } = {}) {
                    Object.assign(this, { x, y, xanchor, yanchor });

                    this.#infoMap = infoMap;
                    this.#forms = Object.entries(infoMap).map(([key, { lname }]) => {
                        return new NamedForm({
                            name: key,
                            lname: `$${lname}$`,
                            type: "checkbox",
                            defaultValue: true,

                            onchange: () => plot.updateData(),
                        });
                    });

                    this.#selector.elem.append(
                        this.#displayToggle.elem,
                        createElement("div", {
                            style: {
                                marginTop: "0.5em",
                                display: "grid",
                                gridTemplateRows: `repeat(${Math.ceil(this.#forms.length / 2)}, auto)`,
                                gridAutoFlow: "column",
                                gap: "0 16px",
                            },
                        }, ...this.#forms.map(({ elem }) => elem)),
                    );
                
                    this.selected = selected;
                }

                get selected() {
                    return this.#forms.filter(form => !form.disabled && form.value).map(({ name }) => name);
                }

                set selected(selected) {
                    for (const form of this.#forms) {
                        form.value = selected.includes(form.name);
                    }
                }

                updateClickTarget() {
                    const { graphtype } = plot.#options;
                    this.#clickTargets.forEach(elem => elem.remove());
                    this.#clickTargets = [];

                    if (!graphtype.startsWith("xyz")) {
                        this.#objects = this.#objects.filter(object => plot.#layout.annotations.includes(object));

                        for (const object of this.#objects) {
                            const target = $$(".annotation")[plot.#layout.annotations.indexOf(object)];
                            if (!target) continue;

                            const { left, top, width, height } = target.getBoundingClientRect();

                            this.#clickTargets.push(createElement("div", {
                                class: "clickable",
                                style: {
                                    position: "absolute",
                                    borderRadius: "8px",
                                    left: `${left - 4}px`,
                                    top: `${top - 4}px`,
                                    width: `${width + 8}px`,
                                    height: `${height + 8}px`,
                                },
                                tabIndex: "0",
                                onclick: e => this.#selector.open(e),
                                oncontextmenu: e => {
                                    this.#clickedIndex = this.#clickTargets.indexOf(e.target);
                                    this.#contextmenu.open(e);

                                    e.stopPropagation();
                                    return false;
                                },
                            }));
                        }
                    }

                    plot.#elem.append(...this.#clickTargets);
                }

                toObject(data) {
                    const text = (
                        this.#customText ? this.#customText
                        : "$" + this.selected.map(key => this.#toText(data[key], this.#infoMap[key])).filter(s => s).join("\\\\") + "$"
                    );
                    const { x, y, xanchor, yanchor } = this;

                    const object = {
                        text,

                        ...(this.#customText || this.selected.length ? {} : { width: 120, height: 80 }),
                        x, y,
                        xanchor, yanchor,
                        xshift: x === 0 ? 12 : x === 1 ? -12 : 0,
                        yshift: y === 0 ? 12 : y === 1 ? -12 : 0,
                        font: { size: 16 },
                        showarrow: false,
                    };

                    this.#objects.push(object);
                    return object;
                }

                #toText(value, { name, lname, unit, SIpow }) {
                    if (!Number.isFinite(value)) {
                        if (Number.isNaN(value)) return `${lname ?? name}=\\text{--}` + (unit && `\\:{\\rm ${unit}}`);
                        else if (value instanceof Date) return `\\text{${value.toLocaleString()}}`;
                    }
                    else {
                        const precision = ["Ibias", "A", "d"].includes(name) ? undefined : 3;

                        if (unit) {
                            const SIprefix = getSIPrefix(round(value, { precision }), SIpow);

                            return `${lname ?? name}=${round(value / SIprefix.value).toPrecision(precision)}\\:{\\rm ${SIprefix.name}${unit}}`;
                        }
                        else {
                            const { abs, log10, floor } = Math;
                            const n = floor(log10(abs(round(value, { precision }))));

                            if (0 <= n && n < 3) {
                                return `${lname ?? name}=${round(value).toPrecision(precision)}`;
                            }
                            else {
                                return `${lname ?? name}=${round(value / 10**n).toPrecision(precision)}\\times10^{${n}}`;
                            }
                        }
                    }
                }
            };
            #annotations = {
                IV1: new this.#Annotation({
                    infoMap: Object.fromEntries(
                        Object.entries(info.data).filter(([, { noAnnotation }]) => !noAnnotation)
                    ),
                    selected: ["T", "Ibias", "A", "d"],
                    x: 0, y: 1, xanchor: "left", yanchor: "top",
                }),
                IV2: new this.#Annotation({
                    infoMap: Object.fromEntries(
                        Object.entries(info.data).filter(([, { noAnnotation }]) => !noAnnotation)
                    ),
                    selected: ["Ic", "Rn", "Rsg", "Vg", "Jc_th"],
                    x: 1, y: 0, xanchor: "right", yanchor: "bottom",
                }),
                "Ic-A": new this.#Annotation({
                    infoMap: info.fits["Ic-A"],
                    selected: ["Jc", "delta_a", "lambda_J"],
                    x: 1, y: 0, xanchor: "right", yanchor: "bottom",
                }),
                "Ic_th-A": new this.#Annotation({
                    infoMap: info.fits["Ic_th-A"],
                    selected: ["Jc", "delta_a", "lambda_J"],
                    x: 1, y: 0, xanchor: "right", yanchor: "bottom",
                }),
                "RnA-A": new this.#Annotation({
                    infoMap: info.fits["RnA-A"],
                    selected: ["delta_a", "RnA"],
                    x: 1, y: 0, xanchor: "right", yanchor: "bottom",
                }),
                "Ic12-Ibias": new this.#Annotation({
                    infoMap: info.fits["Ic12-Ibias"],
                    selected: ["deltaI", "Ioffset", "L", "L1", "L2", "Ic", "Ic1", "Ic2"],
                    x: 0, y: 0.5, xanchor: "left", yanchor: "center",
                }),
            };
            #running = false;
            #waiting = false;
            
            constructor() {
                this.#elem.oncontextmenu = e => this.#contextmenu.open(e);
                this.#elem.onkeydown = e => {
                    if (e.key === "Delete") Plotly.deleteActiveShape(this.#elem);
                };
                new ResizeObserver(() => Plotly.Plots.resize(this.#elem)).observe(this.#elem);

                matchMedia("(prefers-color-scheme: dark)").onchange = () => this.update();
                
                this.#updateData();
                this.#updateLayout();
                Plotly.newPlot(this.#elem, this.#data, this.#layout, this.#config).then(() => {
                    this.#updateModebar();
                    this.#initOffsetter();
                    this.#initColorbarEvent();
                    this.#Axis.axes.forEach(axis => axis.updateClickTarget());

                    this.#elem.on("plotly_afterplot", () => {
                        this.#Axis.axes.forEach(axis => axis.updateClickTarget());

                        Object.values(this.#annotations).forEach(annotation => annotation.updateClickTarget());
                    });
                });
            }

            get settings() {
                return this.#settings.toObject();
            }

            set settings(object = {}) {
                this.#settings.fromObject(object);

                this.updateLayout();
            }

            get targets() {
                return this.#targets;
            }

            set targets(targets) {
                this.#targets = targets;

                this.update();
            }

            async updateData() {
                this.#updateData();
                await this.#react();
            }

            async updateLayout() {
                this.#updateLayout();
                await this.#react();
            }

            async update() {
                this.#controls.update();
                this.#controls2.update();

                this.#updateData();
                this.#updateLayout();
                await this.#react();
            }

            async #react() {
                if (this.#running) this.#waiting = true;
                else {
                    this.#running = true;

                    const layout = this.#options.graphtype.startsWith("xyz") ? this.#layout3d : this.#layout;
                    await Plotly.react(this.#elem, this.#data, layout);
                    this.#running = false;

                    if (this.#waiting) {
                        this.#waiting = false;
                        await this.#react();
                    }
                }
            }

            #updateData() {
                const { graphtype, subplots, fitplot, tracemode, tracetype, markersize, linewidth,
                        showtitle, legend, fontsize } = this.#options;
                const colorway = this.#options.colorway ?? (
                    matchMedia("(prefers-color-scheme: dark)").matches
                    ? ["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"]
                    : ["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"]
                );
                const toString = ({ name, value, unit, SIpow }) => {
                    if (!Number.isFinite(value)) {
                        return `${name} = ${Number.isNaN(value) ? "--" : value}` + (unit && ` ${unit}`);
                    }
                    else {
                        const { name: SIname, value: SIvalue} = getSIPrefix(value, SIpow);
                                
                        return `${name} = ${round(value / SIvalue).toPrecision(7)}` + (unit && ` ${SIname + unit}`);
                    }
                };
                const absmax = a => a.filter(Number.isFinite).map(Math.abs).reduce((max, cur) => cur > max ? cur : max, 0);
                const div = (a, b) => a.map(v => Number.isFinite(v) ? v / b : v);

                if (!graphtype.startsWith("xyz")) {
                    this.#data = [];
                    this.#layout.annotations = [];
                    this.#layout.showlegend = this.targets.length >= 2 && (legend || showtitle) && !subplots;

                    const plotCount = subplots ? Math.max(1, this.targets.length) : 1;
                    const columns = Math.ceil(Math.sqrt(plotCount));
                    const rows = Math.ceil(plotCount / columns);
                    Object.assign(this.#layout.grid, { rows, columns });

                    for (const key of Object.keys(this.#layout)) {
                        const match = key.match(/^[xy]axis(\d*)$/);

                        if (match && Number(match[1] || 1) > plotCount) delete this.#layout[key];
                    }
                    Array(plotCount).fill().forEach((_, i) => {
                        if (i === 0) return;

                        this.#layout[`xaxis${i + 1}`] ??= structuredClone(this.#layout.xaxis);
                        this.#layout[`yaxis${i + 1}`] ??= structuredClone(this.#layout.yaxis);
                    });

                    const dataset = [];
                    this.targets.forEach((result, i) => {
                        if (
                            this.#xaxis.group === this.#Axis.group1
                            && this.#yaxis.group === this.#Axis.group1
                            && (!graphtype.includes("color") || this.#caxis.group === this.#Axis.group1)
                            && result.list) {
                            result = result.selected;
                        }
                        const traces = [{
                            name: result.displayName || `trace${i + 1}`,
                            marker: {
                                color: (
                                    graphtype.includes("color") ? []
                                    : subplots ? colorway[0]
                                    : colorway[i % colorway.length]
                                ),
                                coloraxis: "coloraxis",
                                showscale: true,
                            },
                            mode: tracemode,
                            x: [],
                            y: [],
                        }];

                        if (
                            [this.#xaxis.key, this.#yaxis.key].includes("Ic12")
                            || graphtype.includes("color") && this.#caxis.key === "Ic12"
                        ) {
                            for (const key of ["Ic1", "Ic2"]) {
                                const [xkey, ykey, ckey] = [this.#xaxis, this.#yaxis, this.#caxis].map(axis => (
                                    axis.key !== "Ic12" ? axis.key : key
                                ));
                                const { [xkey]: xdata, [ykey]: ydata, [ckey]: cdata } = result.data;

                                traces[0].x.push(...[xdata].flat(), null);
                                traces[0].y.push(...[ydata].flat(), null);
                                if (graphtype.includes("color")) traces[0].marker.color.push(...[cdata].flat(), null);
                            }
                        }
                        else {
                            for (const { data } of result.list ?? [result]) {
                                const { [this.#xaxis.key]: xdata, [this.#yaxis.key]: ydata, [this.#caxis.key]: cdata } = data;
                                const listed = [xdata, ydata, cdata].find(variable => Array.isArray(variable));

                                if (listed && (graphtype.includes("color") || listed !== cdata)) {
                                    const x = Array.isArray(xdata) ? xdata : [...listed].fill(xdata);
                                    const y = Array.isArray(ydata) ? ydata : [...listed].fill(ydata);
                                    traces[0].x.push(...x, null);
                                    traces[0].y.push(...y, null);
                                    if (graphtype.includes("color")) {
                                        const c = Array.isArray(cdata) ? cdata : [...listed].fill(cdata);
                                        traces[0].marker.color.push(...c, null);
                                    }

                                    if ((this.targets.length === 1 || subplots) && fitplot) {
                                        const calcplots = [];

                                        if (
                                            [this.#xaxis.key, this.#caxis.key].includes("V")
                                            && this.#yaxis.key === "I"
                                        ) {
                                            const { Ic, IcIndex1, IcIndex2,
                                                    Rn, RnIndex1, RnIndex2,
                                                    Rsg, RsgIndex1, RsgIndex2,
                                                    Vg, VgIndex1, VgIndex2 } = data;
                                            
                                                    calcplots.push({
                                                name: "Ic",
                                                x: [x[IcIndex1], x[IcIndex2]],
                                                y: [y[IcIndex1], y[IcIndex2]],
                                                mode: "markers",
                                                marker: { color: colorway[1 % colorway.length] },
                                                hovertemplate: toString({ value: Ic, ...info.data.Ic }).bold() + "<br><br>",
                                            }, {
                                                name: "Rn",
                                                x: [x[RnIndex1], x[RnIndex2]],
                                                y: [y[RnIndex1], y[RnIndex2]],
                                                mode: "markers",
                                                marker: { color: colorway[2 % colorway.length] },
                                                hovertemplate: toString({ value: Rn, ...info.data.Rn }).bold() + "<br><br>",
                                            }, {
                                                name: "Rsg",
                                                x: [x[RsgIndex1], x[RsgIndex2]],
                                                y: [y[RsgIndex1], y[RsgIndex2]],
                                                mode: "markers",
                                                marker: { color: colorway[3 % colorway.length] },
                                                hovertemplate: toString({ value: Rsg, ...info.data.Rsg }).bold() + "<br><br>",
                                            }, {
                                                name: "Vg",
                                                x: [x[VgIndex1], x[VgIndex2]],
                                                y: [y[VgIndex1], y[VgIndex2]],
                                                mode: "markers",
                                                marker: { color: colorway[4 % colorway.length] },
                                                hovertemplate: toString({ value: Vg, ...info.data.Vg }).bold() + "<br><br>",
                                            });
                                        }

                                        else if (
                                            [this.#xaxis.key, this.#caxis.key].includes("V")
                                            && this.#yaxis.key === "dIdV"
                                        ) {
                                            const { Vg, VgIndex1, VgIndex2 } = data;

                                            calcplots.push({
                                                name: "Vg",
                                                x: [x[VgIndex1], x[VgIndex2]],
                                                y: [y[VgIndex1], y[VgIndex2]],
                                                mode: "markers",
                                                marker: { color: colorway[1 % colorway.length] },
                                                hovertemplate: toString({ value: Vg, ...info.data.Vg }).bold() + "<br><br>",
                                            });
                                        }

                                        traces.push(...calcplots);
                                        
                                        // ホバーラベル用のダミープロット
                                        if (tracetype === "scattergl") {
                                            const dummies = calcplots.map(trace => ({ ...trace }));

                                            dummies.forEach(trace => {
                                                trace.hoverlabel = { bgcolor: trace.marker.color };
                                                trace.opacity = 0;
                                                trace.type = "scatter";
                                            });

                                            traces.push(...dummies);
                                        }

                                        if (`${this.#yaxis.key}-${this.#xaxis.key}` in (result.fits ?? {})) {
                                            const { x, y } = result.fits[`${this.#yaxis.key}-${this.#xaxis.key}`];
                                            
                                            traces.push({
                                                name: "fit",
                                                x: x,
                                                y: y,
                                                mode: "lines",
                                            });
                                        }
                                    }
                                }
                                else {
                                    traces[0].x.push(xdata);
                                    traces[0].y.push(ydata);
                                    if (graphtype.includes("color")) traces[0].marker.color.push(cdata);
                                }

                                if (traces[0].x.length > 500000) {
                                    logger.log("プロット数が500000に達したためプロットを中断しました");
                                    break;
                                }
                            }
                        }

                        // アノテーション
                        if (this.targets.length === 1 || subplots) {
                            const posref = {
                                xref: `x${i ? i + 1 : ""} domain`,
                                yref: `y${i ? i + 1 : ""} domain`,
                            };

                            if (showtitle) this.#layout.annotations.push({
                                text: result.displayName,
                                x: 0.5,
                                y: 1.04,
                                yanchor: "bottom",
                                showarrow: false,
                                font: { size: fontsize * 1.2 },

                                ...posref,
                            });

                            if (!result.list && this.#xaxis.key === "V" && ["I", "dIdV"].includes(this.#yaxis.key)) {
                                this.#layout.annotations.push(
                                    Object.assign(this.#annotations.IV1.toObject(result.data), posref),
                                    Object.assign(this.#annotations.IV2.toObject(result.data), posref),
                                );
                            }

                            if (result.fits && `${this.#yaxis.key}-${this.#xaxis.key}` in result.fits) {
                                const name = `${this.#yaxis.key}-${this.#xaxis.key}`;
                                const { params } = result.fits[name];
                                
                                if (name in this.#annotations) {
                                    this.#layout.annotations.push(
                                        Object.assign(this.#annotations[name].toObject(params), posref),
                                    );
                                }
                            }
                        }

                        dataset.push(traces);
                    });

                    // 色軸の設定
                    if (graphtype.includes("color")) {
                        // SI接頭辞の計算, 保存
                        const cSIpre = getSIPrefix(absmax(
                            dataset.flat().map(trace => trace.marker?.color).flat()
                        ), this.#caxis.SIpow);
                        this.#caxis.SIprefix = cSIpre;

                        // 軸タイトルの設定
                        const { name, customName, unit } = this.#caxis;
                        this.#layout.coloraxis.colorbar.title.text = (
                            `${customName ?? name}${unit && ` (${cSIpre.name}${unit})`}`
                        );

                    }

                    (subplots ? dataset : [dataset.flat()]).forEach((traces, i) => {
                        // SI接頭辞の計算, 保存
                        const xSIpre = getSIPrefix(absmax(traces.map(trace => trace.x).flat()), this.#xaxis.SIpow);
                        const ySIpre = getSIPrefix(absmax(traces.map(trace => trace.y).flat()), this.#yaxis.SIpow);
                        if (i === 0) {
                            this.#xaxis.SIprefix = xSIpre;
                            this.#yaxis.SIprefix = ySIpre;
                        }
                        
                        // 軸タイトルの設定
                        for (const [axis, { lname, customName, unit }, SIpreName] of [
                            [this.#layout[`xaxis${i ? i + 1 : ""}`], this.#xaxis, xSIpre.name],
                            [this.#layout[`yaxis${i ? i + 1 : ""}`], this.#yaxis, ySIpre.name],
                        ]) {
                            axis.title = (
                                customName ? `${customName}${unit && ` (${SIpreName}${unit})`}`
                                : `$${lname}${unit && `\\:({\\rm ${SIpreName}${unit}})`}$`
                            );
                        }
                        
                        // 各プロットの設定
                        traces.forEach(trace => {
                            // SI接頭辞の適用
                            if (this.#xaxis.key !== "date") trace.x = div(trace.x, xSIpre.value);
                            if (this.#yaxis.key !== "date") trace.y = div(trace.y, ySIpre.value);
                            if (Array.isArray(trace.marker.color) && this.#caxis.key !== "date") {
                                trace.marker.color = div(trace.marker.color, this.#caxis.SIprefix.value);
                            }

                            // hovertemplateの設定
                            trace.hovertemplate = (trace.hovertemplate ?? "") + [
                                `${this.#xaxis.name} = %{x} ${xSIpre.name}${this.#xaxis.unit}`,
                                `${this.#yaxis.name} = %{y} ${ySIpre.name}${this.#yaxis.unit}`,
                                ...(
                                    Array.isArray(trace.marker.color)
                                    ? [`${this.#caxis.name} = %{marker.color} ${this.#caxis.SIprefix.name}${this.#caxis.unit}`]
                                    : []
                                ),
                            ].join("<br>");
                            if (this.targets.length === 1 || subplots) trace.hovertemplate += "<extra></extra>";

                            // プロットタイプ, サイズ, 線幅の設定
                            trace.type ??= tracetype;
                            if (!trace.marker) trace.marker = {};
                            trace.marker.size = markersize;
                            trace.line = { width: linewidth };

                            // プロットドメインの設定
                            trace.xaxis = "x" + (i ? i + 1 : "");
                            trace.yaxis = "y" + (i ? i + 1 : "");
                        });
                    });

                    this.#data = dataset.flat();
                }

                else {
                    this.#data = [];
                    this.#layout3d.annotations = [];
                    this.#layout3d.showlegend = this.targets.length >= 2 && (legend || showtitle) && !subplots;

                    const plotCount = subplots ? Math.max(1, this.targets.length) : 1;
                    const columns = Math.ceil(Math.sqrt(plotCount));
                    const rows = Math.ceil(plotCount / columns);

                    for (const key of Object.keys(this.#layout3d)) {
                        const match = key.match(/^scene(\d*)$/);

                        if (match && Number(match[1] || 1) > plotCount) delete this.#layout3d[key];
                    }
                    Array(plotCount).fill().forEach((_, i) => {
                        const domain = {
                            x: [(i % columns) / columns, (i % columns + 1) / columns],
                            y: [1 - (Math.floor(i / columns) + 1) / rows, 1 - Math.floor(i / columns) / rows],
                        };

                        if (i === 0) {
                            this.#layout3d.scene.domain = domain;
                        }
                        else {
                            this.#layout3d[`scene${i + 1}`] = {
                                ...structuredClone(this.#layout3d.scene),
                                domain,
                            };
                        }
                    });

                    const dataset = [];
                    this.targets.forEach((result, i) => {
                        if (
                            this.#xaxis3d.group === this.#Axis.group1
                            && this.#yaxis3d.group === this.#Axis.group1
                            && this.#zaxis3d.group === this.#Axis.group1
                            && (!graphtype.includes("color") || this.#caxis3d.group === this.#Axis.group1)
                            && result.list) {
                            result = result.selected;
                        }
                        const traces = [{
                            name: result.displayName || `trace${i + 1}`,
                            marker: {
                                color: (
                                    graphtype.includes("color") ? []
                                    : subplots ? colorway[0]
                                    : colorway[i % colorway.length]
                                ),
                                coloraxis: "coloraxis",
                                showscale: true,
                            },
                            mode: tracemode,
                            x: [],
                            y: [],
                            z: [],
                        }];

                        if (
                            [this.#xaxis3d.key, this.#yaxis3d.key, this.#zaxis3d.key].includes("Ic12")
                            || graphtype.includes("color") && this.#caxis3d.key === "Ic12"
                        ) {
                            for (const key of ["Ic1", "Ic2"]) {
                                const [xkey, ykey, zkey, ckey] = [this.#xaxis3d, this.#yaxis3d, this.#zaxis3d, this.#caxis3d].map(
                                    axis => axis.key !== "Ic12" ? axis.key : key
                                );
                                const { [xkey]: xdata, [ykey]: ydata, [zkey]: zdata, [ckey]: cdata } = result.data;

                                traces[0].x.push(...[xdata].flat(), null);
                                traces[0].y.push(...[ydata].flat(), null);
                                traces[0].z.push(...[zdata].flat(), null);
                                if (graphtype.includes("color")) traces[0].marker.color.push(...[cdata].flat(), null);
                            }
                        }
                        else {
                            for (const { data } of result.list ?? [result]) {
                                const { [this.#xaxis3d.key]: xdata,
                                        [this.#yaxis3d.key]: ydata,
                                        [this.#zaxis3d.key]: zdata,
                                        [this.#caxis3d.key]: cdata } = data;
                                const listed = [xdata, ydata, zdata, cdata].find(variable => Array.isArray(variable));

                                if (listed && (graphtype.includes("color") || listed !== cdata)) {
                                    const x = Array.isArray(xdata) ? xdata : [...listed].fill(xdata);
                                    const y = Array.isArray(ydata) ? ydata : [...listed].fill(ydata);
                                    const z = Array.isArray(zdata) ? zdata : [...listed].fill(zdata);
                                    traces[0].x.push(...x, null);
                                    traces[0].y.push(...y, null);
                                    traces[0].z.push(...z, null);
                                    if (graphtype.includes("color")) {
                                        const c = Array.isArray(cdata) ? cdata : [...listed].fill(cdata);
                                        traces[0].marker.color.push(...c, null);
                                    }

                                    if ((this.targets.length === 1 || subplots) && fitplot) {
                                        if (
                                            [this.#xaxis3d.key, this.#yaxis3d.key, this.#caxis3d.key].includes("V")
                                            && this.#zaxis3d.key === "I"
                                        ) {
                                            const { Ic, IcIndex1, IcIndex2,
                                                    Rn, RnIndex1, RnIndex2,
                                                    Rsg, RsgIndex1, RsgIndex2,
                                                    Vg, VgIndex1, VgIndex2 } = data;
                                            
                                            traces.push({
                                                name: "Ic",
                                                x: [x[IcIndex1], x[IcIndex2]],
                                                y: [y[IcIndex1], y[IcIndex2]],
                                                z: [z[IcIndex1], z[IcIndex2]],
                                                mode: "markers",
                                                marker: { color: colorway[1 % colorway.length] },
                                                hovertemplate: toString({ value: Ic, ...info.data.Ic }).bold() + "<br><br>",
                                            }, {
                                                name: "Rn",
                                                x: [x[RnIndex1], x[RnIndex2]],
                                                y: [y[RnIndex1], y[RnIndex2]],
                                                z: [z[RnIndex1], z[RnIndex2]],
                                                mode: "markers",
                                                marker: { color: colorway[2 % colorway.length] },
                                                hovertemplate: toString({ value: Rn, ...info.data.Rn }).bold() + "<br><br>",
                                            }, {
                                                name: "Rsg",
                                                x: [x[RsgIndex1], x[RsgIndex2]],
                                                y: [y[RsgIndex1], y[RsgIndex2]],
                                                z: [z[RsgIndex1], z[RsgIndex2]],
                                                mode: "markers",
                                                marker: { color: colorway[3 % colorway.length] },
                                                hovertemplate: toString({ value: Rsg, ...info.data.Rsg }).bold() + "<br><br>",
                                            }, {
                                                name: "Vg",
                                                x: [x[VgIndex1], x[VgIndex2]],
                                                y: [y[VgIndex1], y[VgIndex2]],
                                                z: [z[VgIndex1], z[VgIndex2]],
                                                mode: "markers",
                                                marker: { color: colorway[4 % colorway.length] },
                                                hovertemplate: toString({ value: Vg, ...info.data.Vg }).bold() + "<br><br>",
                                            });
                                        }

                                        else if (
                                            [this.#xaxis3d.key, this.#yaxis3d.key, this.#caxis3d.key].includes("V")
                                            && this.#zaxis3d.key === "dIdV"
                                        ) {
                                            const { Vg, VgIndex1, VgIndex2 } = data;

                                            traces.push({
                                                name: "Vg",
                                                x: [x[VgIndex1], x[VgIndex2]],
                                                y: [y[VgIndex1], y[VgIndex2]],
                                                z: [z[VgIndex1], z[VgIndex2]],
                                                mode: "markers",
                                                marker: { color: colorway[4 % colorway.length] },
                                                hovertemplate: toString({ value: Vg, ...info.data.Vg }).bold() + "<br><br>",
                                            });
                                        }
                                    }
                                }
                                else {
                                    traces[0].x.push(xdata);
                                    traces[0].y.push(ydata);
                                    traces[0].z.push(zdata);
                                    if (graphtype.includes("color")) traces[0].marker.color.push(cdata);
                                }

                                if (traces[0].x.length > 100000) {
                                    logger.log("プロット数が100000に達したためプロットを中断しました");
                                    break;
                                }
                            }
                        }

                        // アノテーション
                        if (this.targets.length === 1 || subplots) {
                            const domain = this.#layout3d[`scene${i ? i + 1 : ""}`].domain;

                            if (showtitle) this.#layout3d.annotations.push({
                                text: result.displayName,
                                x: domain.x[0] + (domain.x[1] - domain.x[0]) * 0.5,
                                y: domain.y[0] + (domain.y[1] - domain.y[0]) * 0.95,
                                xanchor: "center",
                                yanchor: "middle",
                                showarrow: false,
                                font: { size: fontsize * 1.2 },
                            });
                        }

                        dataset.push(traces);
                    });

                    // 色軸の設定
                    if (graphtype.includes("color")) {
                        // SI接頭辞の計算, 保存
                        const cSIpre = getSIPrefix(absmax(
                            dataset.flat().map(trace => trace.marker?.color).flat()
                        ), this.#caxis3d.SIpow);
                        this.#caxis3d.SIprefix = cSIpre;

                        // 軸タイトルの設定
                        const { name, customName, unit } = this.#caxis3d;
                        this.#layout3d.coloraxis.colorbar.title.text = (
                            `${customName ?? name}${unit && ` (${cSIpre.name}${unit})`}`
                        );

                    }

                    (subplots ? dataset : [dataset.flat()]).forEach((traces, i) => {
                        // SI接頭辞の計算, 保存
                        const xSIpre = getSIPrefix(absmax(traces.map(trace => trace.x).flat()), this.#xaxis3d.SIpow);
                        const ySIpre = getSIPrefix(absmax(traces.map(trace => trace.y).flat()), this.#yaxis3d.SIpow);
                        const zSIpre = getSIPrefix(absmax(traces.map(trace => trace.z).flat()), this.#zaxis3d.SIpow);
                        if (i === 0) {
                            this.#xaxis3d.SIprefix = xSIpre;
                            this.#yaxis3d.SIprefix = ySIpre;
                            this.#zaxis3d.SIprefix = zSIpre;
                        }
                        
                        // 軸タイトルの設定
                        const { xaxis, yaxis, zaxis } = this.#layout3d[`scene${i ? i + 1 : ""}`];
                        for (const [axis, { name, customName, unit }, SIpreName] of [
                            [xaxis, this.#xaxis3d, xSIpre.name],
                            [yaxis, this.#yaxis3d, ySIpre.name],
                            [zaxis, this.#zaxis3d, zSIpre.name],
                        ]) {
                            axis.title.text = `${customName ?? name}${unit && ` (${SIpreName}${unit})`}`
                        }
                        
                        // 各プロットの設定
                        traces.forEach(trace => {
                            // SI接頭辞の適用
                            if (this.#xaxis3d.key !== "date") trace.x = div(trace.x, xSIpre.value);
                            if (this.#yaxis3d.key !== "date") trace.y = div(trace.y, ySIpre.value);
                            if (this.#zaxis3d.key !== "date") trace.z = div(trace.z, zSIpre.value);
                            if (Array.isArray(trace.marker.color) && this.#caxis3d.key !== "date") {
                                trace.marker.color = div(trace.marker.color, this.#caxis3d.SIprefix.value);
                            }

                            // hovertemplateの設定
                            trace.hovertemplate = (trace.hovertemplate ?? "") + [
                                `${this.#xaxis3d.name} = %{x} ${xSIpre.name}${this.#xaxis3d.unit}`,
                                `${this.#yaxis3d.name} = %{y} ${ySIpre.name}${this.#yaxis3d.unit}`,
                                `${this.#zaxis3d.name} = %{z} ${zSIpre.name}${this.#zaxis3d.unit}`,
                                ...(
                                    Array.isArray(trace.marker.color)
                                    ? [`${this.#caxis3d.name} = %{marker.color} ${this.#caxis3d.SIprefix.name}${this.#caxis3d.unit}`]
                                    : []
                                ),
                            ].join("<br>");
                            if (this.targets.length === 1 || subplots) trace.hovertemplate += "<extra></extra>";

                            // プロットタイプ, サイズ, 線幅の設定
                            trace.type = "scatter3d";
                            if (!trace.marker) trace.marker = {};
                            trace.marker.size = markersize / 3;
                            trace.line = { width: linewidth * 1.5 };

                            // プロットドメインの設定
                            trace.scene = `scene${i ? i + 1 : ""}`;
                        });
                    });

                    this.#data = dataset.flat();
                }
            }

            #updateLayout() {
                const darktheme = (
                    {"data":{"barpolar":[{"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"bar":[{"error_x":{"color":"#f2f5fa"},"error_y":{"color":"#f2f5fa"},"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"carpet":[{"aaxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"baxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"type":"carpet"}],"choropleth":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"choropleth"}],"contourcarpet":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"contourcarpet"}],"contour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"contour"}],"heatmapgl":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmapgl"}],"heatmap":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmap"}],"histogram2dcontour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2dcontour"}],"histogram2d":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2d"}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"mesh3d":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"mesh3d"}],"parcoords":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"parcoords"}],"pie":[{"automargin":true,"type":"pie"}],"scatter3d":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatter3d"}],"scattercarpet":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattercarpet"}],"scattergeo":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattergeo"}],"scattergl":[{"marker":{"line":{"color":"#283442"}},"type":"scattergl"}],"scattermapbox":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattermapbox"}],"scatterpolargl":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolargl"}],"scatterpolar":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolar"}],"scatter":[{"marker":{"line":{"color":"#283442"}},"type":"scatter"}],"scatterternary":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterternary"}],"surface":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"surface"}],"table":[{"cells":{"fill":{"color":"#506784"},"line":{"color":"rgb(17,17,17)"}},"header":{"fill":{"color":"#2a3f5f"},"line":{"color":"rgb(17,17,17)"}},"type":"table"}]},"layout":{"annotationdefaults":{"arrowcolor":"#f2f5fa","arrowhead":0,"arrowwidth":1},"autotypenumbers":"strict","coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]],"sequential":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"sequentialminus":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]]},"colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#f2f5fa"},"geo":{"bgcolor":"rgb(17,17,17)","lakecolor":"rgb(17,17,17)","landcolor":"rgb(17,17,17)","showlakes":true,"showland":true,"subunitcolor":"#506784"},"hoverlabel":{"align":"left"},"hovermode":"closest","mapbox":{"style":"dark"},"paper_bgcolor":"rgb(17,17,17)","plot_bgcolor":"rgb(17,17,17)","polar":{"angularaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","radialaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"scene":{"xaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"yaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"zaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"}},"shapedefaults":{"line":{"color":"#f2f5fa"}},"sliderdefaults":{"bgcolor":"#C8D4E3","bordercolor":"rgb(17,17,17)","borderwidth":1,"tickwidth":0},"ternary":{"aaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"baxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","caxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"title":{"x":0.05},"updatemenudefaults":{"bgcolor":"#506784","borderwidth":0},"xaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2},"yaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2}}}
                );
                const {
                    graphtype, tracemode, colorway,
                    showtitle, legend, logscale, logscale3d, frame, ticks, grid, darkmode,
                    fontsize, fontfamily } = this.#options;

                if (!graphtype.startsWith("xyz")) {
                    const xaxes = [];
                    const yaxes = [];
                    for (const [key, value] of Object.entries(this.#layout)) {
                        if (key.includes("xaxis")) xaxes.push(value);
                        if (key.includes("yaxis")) yaxes.push(value);
                    }

                    for (const xaxis of xaxes) {
                        xaxis.type = logscale.includes("X") ? "log" : "";
                        xaxis.exponentformat = logscale.includes("X") ? "power" : "";
                    }
                    for (const yaxis of yaxes) {
                        yaxis.type = logscale.includes("Y") ? "log" : "";
                        yaxis.exponentformat = logscale.includes("Y") ? "power" : "";
                    }
                    for (const axis of [...xaxes, ...yaxes]) {
                        axis.showline = !!frame;
                        axis.mirror = frame === "all" && "ticks";
                        axis.ticks = ticks && frame ? "inside" : "";
                        axis.minor.ticks = ticks === "all" && frame ? "inside" : "";
                        axis.showgrid = grid === "auto" ? ticks : !!grid;
                        axis.minor.showgrid = grid === "auto" ? ticks === "all" : grid === "all";
                    }

                    this.#layout.coloraxis.showscale = graphtype.includes("color");
                    this.#layout.margin = showtitle ? null : { t: 80 };
                    this.#layout.legend = (
                        legend === null ? {
                            xanchor: "center",
                            yanchor: "middle",
                            x: 0.5,
                            y: 1.06,
                            orientation: "h",
                            bgcolor: "transparent",
                        } : legend === "lefttop" ? {
                            xanchor: "left",
                            yanchor: "top",
                            x: 0,
                            y: 1,
                            bgcolor: "transparent",
                            borderwidth: 4,
                            bordercolor: "transparent",
                        } : legend === "righttop" ? {
                            xanchor: "right",
                            yanchor: "top",
                            x: 1,
                            y: 1,
                            bgcolor: "transparent",
                            borderwidth: 4,
                            bordercolor: "transparent",
                        } : legend === "leftbottom" ? {
                            xanchor: "left",
                            yanchor: "bottom",
                            x: 0,
                            y: 0,
                            bgcolor: "transparent",
                            borderwidth: 4,
                            bordercolor: "transparent",
                        } : legend === "rightbottom" ? {
                            xanchor: "right",
                            yanchor: "bottom",
                            x: 1,
                            y: 0,
                            bgcolor: "transparent",
                            borderwidth: 4,
                            bordercolor: "transparent",
                        } : {}
                    );
                    this.#layout.colorway = colorway;
                    this.#layout.font.size = fontsize;
                    this.#layout.font.family = fontfamily;
                    this.#layout.template = (darkmode ?? matchMedia("(prefers-color-scheme: dark)").matches) ? darktheme : (
                        {
                            layout: {
                                font: { color: "black" },
                                xaxis: {
                                    color: "black",
                                    title: { standoff: 15 },
                                },
                                yaxis: {
                                    color: "black",
                                    title: { standoff: 15 },
                                },
                            },
                        }
                    );
                }

                else {
                    const xaxes = [];
                    const yaxes = [];
                    const zaxes = [];
                    for (const [key, value] of Object.entries(this.#layout3d)) {
                        if (key.includes("scene")) {
                            xaxes.push(value.xaxis);
                            yaxes.push(value.yaxis);
                            zaxes.push(value.zaxis);
                        }
                    }

                    for (const xaxis of xaxes) {
                        xaxis.type = logscale3d.includes("X") ? "log" : "";
                        xaxis.exponentformat = logscale3d.includes("X") ? "power" : "";
                    }
                    for (const yaxis of yaxes) {
                        yaxis.type = logscale3d.includes("Y") ? "log" : "";
                        yaxis.exponentformat = logscale3d.includes("Y") ? "power" : "";
                    }
                    for (const zaxis of zaxes) {
                        zaxis.type = logscale3d.includes("Z") ? "log" : "";
                        zaxis.exponentformat = logscale3d.includes("Z") ? "power" : "";
                    }
                    for (const axis of [...xaxes, ...yaxes, ...zaxes]) {
                        axis.title.font = { size: fontsize * 1.4 };
                        axis.tickfont = { size: fontsize * 0.86 };

                        axis.showline = !!frame;
                        axis.mirror = frame === "all" && "ticks";
                        axis.ticks = ticks && frame ? "inside" : "";
                        axis.showgrid = grid === "auto" ? ticks : !!grid;
                    }

                    this.#layout3d.coloraxis.showscale = graphtype.includes("color");
                    this.#layout3d.legend = (
                        legend === null ? {
                            xanchor: "center",
                            yanchor: "middle",
                            x: 0.5,
                            y: 0.96,
                            orientation: "h",
                            bgcolor: "transparent",
                        } : legend === "lefttop" ? {
                            xanchor: "left",
                            yanchor: "top",
                            x: 0,
                            y: 1,
                            bgcolor: "transparent",
                            borderwidth: 4,
                            bordercolor: "transparent",
                        } : legend === "righttop" ? {
                            xanchor: "right",
                            yanchor: "top",
                            x: 1,
                            y: 1,
                            bgcolor: "transparent",
                            borderwidth: 4,
                            bordercolor: "transparent",
                        } : legend === "leftbottom" ? {
                            xanchor: "left",
                            yanchor: "bottom",
                            x: 0,
                            y: 0,
                            bgcolor: "transparent",
                            borderwidth: 4,
                            bordercolor: "transparent",
                        } : legend === "rightbottom" ? {
                            xanchor: "right",
                            yanchor: "bottom",
                            x: 1,
                            y: 0,
                            bgcolor: "transparent",
                            borderwidth: 4,
                            bordercolor: "transparent",
                        } : {}
                    );
                    this.#layout3d.colorway = colorway;
                    this.#layout3d.font.size = fontsize;
                    this.#layout3d.font.family = fontfamily;
                    this.#layout3d.template = (darkmode ?? matchMedia("(prefers-color-scheme: dark)").matches) ? darktheme : (
                        {
                            layout: {
                                font: { color: "black" },
                                scene: {
                                    xaxis: { color: "black" },
                                    yaxis: { color: "black" },
                                    zaxis: { color: "black" },
                                },
                            },
                        }
                    );
                }
            }

            #updateModebar() {
                for (const button of this.#config?.modeBarButtonsToAdd ?? []) {
                    const elem = $(`.modebar-btn[data-title="${button.name}"]`);

                    if (button.graphtype) elem.hidden = !button.graphtype.includes(this.#options.graphtype);
                    if (button.group !== undefined) $$(".modebar-group")[button.group].append(elem);
                }
            }

            #initOffsetter() {
                const button = createElement("button", null, "オフセットを設定");
                const menu = new Contextmenu(null, button);

                const xline = createElement("div", {
                    style: {
                        position: "absolute",
                        zIndex: "1",

                        border: "1px solid #ccc",
                        mixBlendMode: "difference",
                        pointerEvents: "none",
                    },
                    hidden: true,
                });
                const yline = createElement("div", {
                    style: {
                        position: "absolute",
                        zIndex: "1",

                        border: "1px solid #ccc",
                        mixBlendMode: "difference",
                        pointerEvents: "none",
                    },
                    hidden: true,
                });
                const xvalue = createElement("div", {
                    style: {
                        position: "absolute",
                        width: "0",
                        height: "0",
                        zIndex: "1",

                        display: "flex",
                        alignItems: "end",
                        color: "#ccc",
                        mixBlendMode: "difference",
                        font: "18px Times New Roman",
                        justifyContent: "center",
                        pointerEvents: "none",
                        whiteSpace: "nowrap",
                    },
                    hidden: true,
                });
                const yvalue = createElement("div", {
                    style: {
                        position: "absolute",
                        height: "0",
                        zIndex: "1",

                        display: "flex",
                        alignItems: "center",
                        color: "#ccc",
                        mixBlendMode: "difference",
                        font: "18px Times New Roman",
                        paddingLeft: "3px",
                        pointerEvents: "none",
                        whiteSpace: "nowrap",
                    },
                    hidden: true,
                });
                let dragarea, index, hoverlayer;
                let x, y, mousedown, requestID;
                
                const update = () => {
                    const { left, right, top, bottom, width, height } = dragarea.getBoundingClientRect();
                    const {
                        [`xaxis${index ? index + 1 : ""}`]: xaxis,
                        [`yaxis${index ? index + 1 : ""}`]: yaxis } = this.#elem._fullLayout;

                    if (left <= x && x <= right) {
                        xline.hidden = false;
                        xline.style.left = `${x}px`;
                        xline.style.top = `${top}px`;
                        xline.style.height = `${height}px`;
                        
                        xvalue.hidden = false;
                        xvalue.style.left = `${x}px`;
                        xvalue.style.top = `${top}px`;
                        xvalue.textContent = round(xaxis.p2c(x - left), { minOrder: xaxis.p2c(x - left + 1) - xaxis.p2c(x - left) });
                    }
                    else {
                        xline.hidden = true;
                        xvalue.hidden = true;
                    }

                    if (top <= y && y <= bottom) {
                        yline.hidden = false;
                        yline.style.left = `${left}px`;
                        yline.style.top = `${y}px`;
                        yline.style.width = `${width}px`;
                        
                        yvalue.hidden = false;
                        yvalue.style.left = `${right}px`;
                        yvalue.style.top = `${y}px`;
                        yvalue.textContent = round(yaxis.p2c(y - top), { minOrder: yaxis.p2c(y - top + 1) - yaxis.p2c(y - top) });
                    }
                    else {
                        yline.hidden = true;
                        yvalue.hidden = true;
                    }
                };
                const startAnimation = () => {
                    update();
                    requestID = requestAnimationFrame(startAnimation);
                };
                const stopAnimation = () => {
                    update();
                    cancelAnimationFrame(requestID);
                };

                const onmousedown = e => {
                    if (e.button !== 2) return;

                    const elems = $$(".nsewdrag");
                    elems.forEach(elem => {
                        elem.oncontextmenu = e => {
                            e.stopPropagation();
                            return false;
                        };
                    });
                    index = elems.findIndex(elem => {
                        const { left, right, top, bottom } = elem.getBoundingClientRect();
                        return left < e.x && e.x < right && top < e.y && e.y < bottom;
                    });
                    if (index === -1) return;

                    dragarea = elems[index];
                    hoverlayer = $(".hoverlayer");
                    e.stopPropagation();

                    mousedown = true;
                    xline.hidden = false;
                    yline.hidden = false;
                    xvalue.hidden = false;
                    yvalue.hidden = false;
                    dragarea.style.cursor = "none";
                    hoverlayer.setAttribute("display", "none");

                    addEventListener("mousemove", onmousemove);
                    addEventListener("mouseup", onmouseup);
                    startAnimation();
                    onmousemove(e);
                };

                const onmousemove = e => {
                    if ((e.buttons & 2) !== 2) return;
                    
                    x = e.x;
                    y = e.y;
                };

                const onmouseup = async e => {
                    if (e.button !== 2) return;

                    removeEventListener("mousemove", onmousemove);
                    removeEventListener("mouseup", onmouseup);
                    stopAnimation();
                    dragarea.style.cursor = "";
                    mousedown = false;

                    const willSetOffset = (
                        e.target === dragarea
                        && this.targets.length
                        && this.#xaxis.name === "V"
                        && this.#yaxis.name === "I"
                        && await new Promise(resolve => {
                            button.onclick = () => {
                                menu.onclose = null;
                                menu.close();
                                resolve(true);
                            };
                            menu.onclose = () => {
                                resolve(false);
                            };

                            menu.open({ x: x, y: y, xmargin: 8, ymargin: 8 });
                        })
                    );
                    if (mousedown) return;

                    xline.hidden = true;
                    yline.hidden = true;
                    xvalue.hidden = true;
                    yvalue.hidden = true;
                    hoverlayer.setAttribute("display", "");
                    if (!willSetOffset) return;

                    const [ xSIpre, ySIpre ] = [this.#xaxis.SIprefix, this.#yaxis.SIprefix];

                    for (const result of this.#options.subplots ? [this.targets[index]] : this.targets) {
                        const { Voffset, Ioffset } = result.calcparams;

                        Object.assign(result.calcparams, {
                            Voffset: round(Number(xvalue.textContent) * xSIpre.value + Voffset),
                            Ioffset: round(Number(yvalue.textContent) * ySIpre.value + Ioffset),
                        });
                        result.saved = false;
                        info.calcparams.Voffset.defaultValue = result.calcparams.Voffset;
                        info.calcparams.Ioffset.defaultValue = result.calcparams.Ioffset;

                        result.calc();
                    }

                    this.update();
                };

                this.#elem.append(xline, yline, xvalue, yvalue);
                this.#elem.addEventListener("mousedown", onmousedown, true);
            }
            
            #initColorbarEvent() {
                this.#elem.addEventListener("click", e => {
                    const cbfills = $(".cbfills");
                    if (!cbfills) return;

                    const { right, top, bottom, width, height } = cbfills.getBoundingClientRect();
                    const isTop = right < e.x && e.x < right + width / 2 && top < e.y && e.y < top + height / 8;
                    const isBottom = right < e.x && e.x < right + width / 2 && bottom - height / 8 < e.y && e.y < bottom;

                    if (isTop || isBottom) {
                        e.stopPropagation();
                        const layout = this.#options.graphtype.startsWith("xyz") ? this.#layout3d : this.#layout;

                        const input = createElement("input", {
                            style: {
                                position: "absolute",
                                left: `${right}px`,
                                ...(isTop ? { top: `${top}px` } : { bottom: `${this.#elem.offsetHeight - bottom}px` }),
                                margin: "0",

                                backdropFilter: "blur(10px)",
                                border: "none",
                                borderRadius: "0",
                                fontSize: "1em",
                                outline: "none",
                                padding: "0",
                            },
                            type: "text",
                            value: (
                                isTop ? this.#elem._fullLayout.coloraxis.cmax
                                : this.#elem._fullLayout.coloraxis.cmin
                            ),
                            onblur: () => {
                                const value = input.value === "" ? NaN : Number(input.value);
                                if (Number.isFinite(value)) {
                                    layout.coloraxis.cauto = false;
                                    if (isTop) layout.coloraxis.cmax = value;
                                    else layout.coloraxis.cmin = value;

                                    this.updateLayout();
                                }

                                input.remove();
                            },
                            onkeydown: e => {
                                e.stopPropagation();

                                if (e.keyCode === 13) input.blur();
                            },
                        });

                        this.#elem.append(input);
                        input.select();
                    }
                }, true);

                this.#elem.addEventListener("dblclick", e => {
                    const cbfills = $(".cbfills");
                    if (!cbfills) return;

                    const { right, top, bottom, width, height } = cbfills.getBoundingClientRect();
                    if (right < e.x && e.x < right + width / 2 && top + height / 8 < e.y && e.y < bottom - height / 8) {
                        e.stopPropagation();
                        const layout = this.#options.graphtype.startsWith("xyz") ? this.#layout3d : this.#layout;

                        if (!this.#layout.coloraxis.cauto) {
                            layout.coloraxis.cauto = true;
                            layout.coloraxis.cmax = null;
                            layout.coloraxis.cmin = null;

                            this.updateLayout();
                        }
                    }
                }, true);
            }

            toJSON() {
                const { data, layout } = this.#elem;

                return { data, layout };
            }

            async toImage(format = "png") {
                const { figsize, dpi } = this.settings;
                const [width, height] = (
                    figsize === "表示サイズ" ? [plot.#elem.offsetWidth, plot.#elem.offsetHeight]
                    : figsize.split("×").map(value => Number(value) * 100)
                );
                const options = {
                    format,
                    width,
                    height,
                    scale: dpi / 100,
                };

                return await (await fetch(await Plotly.toImage(this.#elem, options))).blob();
            }
            
            async #saveAsImage() {
                try {
                    const result = this.targets[0];

                    const fileHandle = await showSaveFilePicker({
                        suggestedName: result ? result.displayName : "plot",
                        types: [
                            {
                                description: "PNG ファイル",
                                accept: { "image/png": [".png"] },
                            },
                            {
                                description: "SVG ファイル",
                                accept: { "image/svg+xml": [".svg"] },
                            },
                            {
                                description: "JPEG ファイル",
                                accept: { "image/jpeg": [".jpg"] },
                            },
                            {
                                description: "WEBP ファイル",
                                accept: { "image/webp": [".webp"] },
                            },
                            {
                                description: "JSON ファイル",
                                accept: { "application/json": [".json"] },
                            },
                        ],
                        excludeAcceptAllOption: true,
                        multiple: false,
                    });

                    const ext = fileHandle.name.split(".").slice(-1)[0];
                    if (ext === "json") {
                        const writable = await fileHandle.createWritable();
                        await writable.write(JSON.stringify(this));
                        await writable.close();
                    }
                    else {
                        const format = { svg: "svg", jpg: "jpeg", webp: "webp" }[ext] ?? "png";
                        const image = await this.toImage(format);

                        const writable = await fileHandle.createWritable();
                        await writable.write(image);
                        await writable.close();
                    }
                    
                    logger.log(`${fileHandle.name}を保存しました`);
                }
                catch (error) {
                    if (!(error instanceof DOMException)) throw error;
                }
            }
        }();

        ResizeBorder.add("#controls", "left");

        addEventListener("keydown", e => {
            // F5, Ctrl+Rを禁止
            if (e.keyCode === 82 || e.keyCode === 116) e.preventDefault();
        });

        onbeforeunload = e => {
            if (measurement.running || !results.saved) {
                e.preventDefault();
                e.returnValue = "";
            }
        };

        $("#measurement-button").style.display = "none";
        $("#fit-button").style.display = "none";
    </script>
</body>

</html>